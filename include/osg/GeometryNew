/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_GEOMETRYNEW
#define OSG_GEOMETRYNEW 1

#include <osg/Drawable>
#include <osg/Vec2>
#include <osg/Vec3>
#include <osg/Vec4>
#include <osg/Array>
#include <osg/PrimitiveSet>

namespace osg {

class OSG_EXPORT GeometryNew : public Drawable
{
    public:

        GeometryNew();

        /** Copy constructor using CopyOp to manage deep vs shallow copy. */
        GeometryNew(const GeometryNew& geometry,const CopyOp& copyop=CopyOp::SHALLOW_COPY);

        virtual Object* cloneType() const { return new GeometryNew(); }
        virtual Object* clone(const CopyOp& copyop) const { return new GeometryNew(*this,copyop); }
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const GeometryNew*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "GeometryNew"; }

#if 0
        virtual Geometry* asGeometry() { return this; }
        virtual const Geometry* asGeometry() const { return this; }
#endif

        bool empty() const;

        /** Same values as Array::Binding.*/
        enum AttributeBinding
        {
            BIND_OFF=0,
            BIND_OVERALL=1,
            BIND_PER_PRIMITIVE_SET=2,
            BIND_PER_PRIMITIVE=3, /// deprecated
            BIND_PER_VERTEX=4
        };

        typedef std::vector< osg::ref_ptr<osg::Array> >  ArrayList;

        void setVertexArray(Array* array);
        Array* getVertexArray() { return _vertexArray.get(); }
        const Array* getVertexArray() const  { return _vertexArray.get(); }


        void setNormalBinding(AttributeBinding ab);
        AttributeBinding getNormalBinding() const;

        void setNormalArray(Array* array);
        Array* getNormalArray() { return _normalArray.get(); }
        const Array* getNormalArray() const { return _normalArray.get(); }

        
        void setColorBinding(AttributeBinding ab);
        AttributeBinding getColorBinding() const;

        void setColorArray(Array* array);
        Array* getColorArray() { return _colorArray.get(); }
        const Array* getColorArray() const { return _colorArray.get(); }


        void setSecondaryColorBinding(AttributeBinding ab);
        AttributeBinding getSecondaryColorBinding() const;

        void setSecondaryColorArray(Array* array);
        Array* getSecondaryColorArray() { return _secondaryColorArray.get(); }
        const Array* getSecondaryColorArray() const;


        void setFogCoordBinding(AttributeBinding ab);
        AttributeBinding getFogCoordBinding() const;

        void setFogCoordArray(Array* array);
        Array* getFogCoordArray() { return _fogCoordArray.get(); }
        const Array* getFogCoordArray() const { return _fogCoordArray.get(); }


        void setTexCoordArray(unsigned int unit,Array*);
        Array* getTexCoordArray(unsigned int unit);
        const Array* getTexCoordArray(unsigned int unit) const;

        unsigned int getNumTexCoordArrays() const {  return static_cast<unsigned int>(_texCoordList.size()); }
        ArrayList& getTexCoordArrayList() { return _texCoordList; }
        const ArrayList& getTexCoordArrayList() const { return _texCoordList; }



        void setVertexAttribArray(unsigned int index,Array* array);
        Array *getVertexAttribArray(unsigned int index);
        const Array *getVertexAttribArray(unsigned int index) const;

        void setVertexAttribBinding(unsigned int index,AttributeBinding ab);
        AttributeBinding getVertexAttribBinding(unsigned int index) const;

        void setVertexAttribNormalize(unsigned int index,GLboolean norm);
        GLboolean getVertexAttribNormalize(unsigned int index) const;

        unsigned int getNumVertexAttribArrays() const { return static_cast<unsigned int>(_vertexAttribList.size()); }
        ArrayList& getVertexAttribArrayList() { return _vertexAttribList; }
        const ArrayList& getVertexAttribArrayList() const { return _vertexAttribList; }



        typedef std::vector< ref_ptr<PrimitiveSet> > PrimitiveSetList;

        void setPrimitiveSetList(const PrimitiveSetList& primitives);

        PrimitiveSetList& getPrimitiveSetList() { return _primitives; }
        const PrimitiveSetList& getPrimitiveSetList() const { return _primitives; }

        unsigned int getNumPrimitiveSets() const { return static_cast<unsigned int>(_primitives.size()); }
        PrimitiveSet* getPrimitiveSet(unsigned int pos) { return _primitives[pos].get(); }
        const PrimitiveSet* getPrimitiveSet(unsigned int pos) const { return _primitives[pos].get(); }

        /** Add a primitive set to the geometry. */
        bool addPrimitiveSet(PrimitiveSet* primitiveset);

        /** Set a primitive set to the specified position in geometry's primitive set list. */
        bool setPrimitiveSet(unsigned int i,PrimitiveSet* primitiveset);

        /** Insert a primitive set to the specified position in geometry's primitive set list. */
        bool insertPrimitiveSet(unsigned int i,PrimitiveSet* primitiveset);

        /** Remove primitive set(s) from the specified position in geometry's primitive set list. */
        bool removePrimitiveSet(unsigned int i,unsigned int numElementsToRemove=1);

        /** Get the index number of a primitive set, return a value between
          * 0 and getNumPrimitiveSet()-1 if found, if not found then return getNumPrimitiveSet().
          * When checking for a valid find value use if ((value=geometry->getPrimitiveSetIndex(primitive))!=geometry.getNumPrimitiveSet())
        */
        unsigned int getPrimitiveSetIndex(const PrimitiveSet* primitiveset) const;




        /** When set to true, ignore the setUseDisplayList() settings, and hints to the drawImplementation
            method to use OpenGL vertex buffer objects for rendering.*/
        virtual void setUseVertexBufferObjects(bool flag);

        /** Force a recompile on next draw() of any OpenGL display list associated with this geoset.*/
        virtual void dirtyDisplayList();


        /** Resize any per context GLObject buffers to specified size. */
        virtual void resizeGLObjectBuffers(unsigned int maxSize);

        /** If State is non-zero, this function releases OpenGL objects for
          * the specified graphics context. Otherwise, releases OpenGL objects
          * for all graphics contexts. */
        virtual void releaseGLObjects(State* state=0) const;

        bool getArrayList(ArrayList& arrayList) const;

        typedef std::vector<osg::DrawElements*>  DrawElementsList;
        bool getDrawElementsList(DrawElementsList& drawElementsList) const;

        osg::VertexBufferObject* getOrCreateVertexBufferObject();
        osg::ElementBufferObject* getOrCreateElementBufferObject();


        bool verifyBindings() const;

        void computeCorrectBindingsAndArraySizes();

        /** check whether the arrays, indices, bindings and primitives all match correctly, return false is .*/
        bool verifyArrays(std::ostream& out) const;


        bool containsSharedArrays() const;

        void duplicateSharedArrays();



        /** Return the estimated size of GLObjects (display lists/vertex buffer objects) that are associated with this drawable.
          * This size is used a hint for reuse of deleted display lists/vertex buffer objects. */
        virtual unsigned int getGLObjectSizeHint() const;

        /** Immediately compile this \c Drawable into an OpenGL Display List/VertexBufferObjects.
          * @note Operation is ignored if \c _useDisplayList is \c false or VertexBufferObjects are not used.
        */
        virtual void compileGLObjects(RenderInfo& renderInfo) const;

        /** Draw Geometry directly ignoring an OpenGL display list which could be attached.
          * This is the internal draw method which does the drawing itself,
          * and is the method to override when deriving from Geometry for user-drawn objects.
        */
        virtual void drawImplementation(RenderInfo& renderInfo) const;

        /** Return true, osg::Geometry does support accept(Drawable::AttributeFunctor&). */
        virtual bool supports(const Drawable::AttributeFunctor&) const { return true; }

        /** Accept an Drawable::AttributeFunctor and call its methods to tell it about the internal attributes that this Drawable has. */
        virtual void accept(Drawable::AttributeFunctor& af);

        /** Return true, osg::Geometry does support accept(Drawable::ConstAttributeFunctor&). */
        virtual bool supports(const Drawable::ConstAttributeFunctor&) const { return true; }

        /** Accept a Drawable::ConstAttributeFunctor and call its methods to tell it about the internal attributes that this Drawable has. */
        virtual void accept(Drawable::ConstAttributeFunctor& af) const;

        /** Return true, osg::Geometry does support accept(PrimitiveFunctor&). */
        virtual bool supports(const PrimitiveFunctor&) const { return true; }

        /** Accept a PrimitiveFunctor and call its methods to tell it about the internal primitives that this Drawable has. */
        virtual void accept(PrimitiveFunctor& pf) const;

        /** Return true, osg::Geometry does support accept(PrimitiveIndexFunctor&). */
        virtual bool supports(const PrimitiveIndexFunctor&) const { return true; }

        /** Accept a PrimitiveFunctor and call its methods to tell it about the internal primitives that this Drawable has. */
        virtual void accept(PrimitiveIndexFunctor& pf) const;


    protected:

        GeometryNew& operator = (const GeometryNew&) { return *this;}

        virtual ~GeometryNew();

        bool verifyBindings(const osg::ref_ptr<Array>& array) const;

        void computeCorrectBindingsAndArraySizes(osg::ref_ptr<Array>& ,const char* arrayName);

        void addVertexBufferObjectIfRequired(osg::Array* array);
        void addElementBufferObjectIfRequired(osg::PrimitiveSet* primitiveSet);


        PrimitiveSetList                _primitives;
        osg::ref_ptr<Array>             _vertexArray;
        osg::ref_ptr<Array>             _normalArray;
        osg::ref_ptr<Array>             _colorArray;
        osg::ref_ptr<Array>             _secondaryColorArray;
        osg::ref_ptr<Array>             _fogCoordArray;
        ArrayList                       _texCoordList;
        ArrayList                       _vertexAttribList;
};

/** Convenience function to be used for creating quad geometry with texture coords.
  * Tex coords go from left bottom (l,b) to right top (r,t).
*/
extern OSG_EXPORT GeometryNew* createTexturedQuadGeometryNew(const Vec3& corner,const Vec3& widthVec,const Vec3& heightVec, float l, float b, float r, float t);

/** Convenience function to be used for creating quad geometry with texture coords.
  * Tex coords go from bottom left (0,0) to top right (s,t).
*/
inline GeometryNew* createTexturedQuadGeometryNew(const Vec3& corner,const Vec3& widthVec,const Vec3& heightVec, float s=1.0f, float t=1.0f)
{
    return createTexturedQuadGeometryNew(corner,widthVec,heightVec, 0.0f, 0.0f, s, t);
}


}

#endif
