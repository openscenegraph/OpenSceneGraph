/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
 * Copyright (C) 2016 Julien Valentin
*/

#ifndef OSG_INDIRECTPRIMITIVESET
#define OSG_INDIRECTPRIMITIVESET 1

#include <osg/PrimitiveSet>


namespace osg {

/**    assuming this structure
*   typedef  struct {
*        uint  count;
*        uint  instanceCount;
*        uint  first;
*        uint  baseInstance;
*    } DrawArraysIndirectCommand;
**/
class DrawArraysIndirectCommand: public BufferData, public VectorGLuint
{
public:
META_Object(osg,DrawArraysIndirectCommand)
DrawArraysIndirectCommand();
DrawArraysIndirectCommand(const DrawArraysIndirectCommand& copy,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
  virtual const GLvoid*   getDataPointer() const { return empty()?0:&front(); }
  virtual unsigned int    getTotalDataSize() const { return static_cast<unsigned int>(size()); }
};

class OSG_EXPORT DrawArraysIndirect : public PrimitiveSet
{
    public:

        DrawArraysIndirect(GLenum mode=0):
            PrimitiveSet(DrawArraysIndirectPrimitiveType,mode),_indirect(0), _indirectCommand(0){}

        DrawArraysIndirect(GLenum mode, GLint first, GLsizei count):
            PrimitiveSet(DrawArraysIndirectPrimitiveType, mode, 0),_indirect(0), _indirectCommand(0){}

        DrawArraysIndirect(const DrawArraysIndirect& da,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            PrimitiveSet(da,copyop), _indirect(da._indirect), _indirectCommand(da._indirectCommand){}

        virtual Object* cloneType() const { return new DrawArraysIndirect(); }
        virtual Object* clone(const CopyOp& copyop) const { return new DrawArraysIndirect(*this,copyop); }
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawArraysIndirect*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "DrawArraysIndirect"; }


        void set(GLenum mode,void * indirectoffset)
        {
            _mode = mode;
            _indirect = indirectoffset;
        }


        void setIndirectOffset( void * i){ _indirect = i; }
        void * getIndirectOffset()const{ return _indirect; }

        virtual void draw(State& state, bool useVertexBufferObjects, bool bindElementBuffer=true) const;

        virtual void accept(PrimitiveFunctor& functor) const;
        virtual void accept(PrimitiveIndexFunctor& functor) const;

        //no meaning in this context
        virtual unsigned int getNumIndices() const { return 0; }
        virtual unsigned int index(unsigned int pos) const { return 0; }
        virtual void offsetIndices(int offset) {}

        inline void setIndirectCommand(DrawArraysIndirectCommand*idc){_indirectCommand = idc;    if(!_indirectCommand->getBufferObject())
        _indirectCommand->setBufferObject(new osg::VertexBufferObject());}
        inline DrawArraysIndirectCommand* getIndirectCommand()const{return _indirectCommand;}

    protected:

        virtual ~DrawArraysIndirect() {}

        void *  _indirect;
        ref_ptr<DrawArraysIndirectCommand> _indirectCommand;
};


/** assuming this structure
*   typedef  struct {
*        uint  count;
*        uint  primCount/instanceCount;
*        uint  firstIndex;
*        uint  baseVertex;
*        uint  baseInstance;
*    } DrawElementsIndirectCommand;
**/

class DrawElementsIndirectCommand: public BufferData, public VectorGLuint
{
public:
META_Object(osg,DrawElementsIndirectCommand)
DrawElementsIndirectCommand();
DrawElementsIndirectCommand(const DrawElementsIndirectCommand& copy,const CopyOp& copyop=CopyOp::SHALLOW_COPY);
  virtual const GLvoid*   getDataPointer() const { return empty()?0:&front(); }
  virtual unsigned int    getTotalDataSize() const { return static_cast<unsigned int>(size()); }



};

class DrawElementsIndirect : public DrawElements
{
    public:

        DrawElementsIndirect(Type primType=PrimitiveType, GLenum mode=0, void *  indirect=0):
            DrawElements(primType,mode, 0),_indirect(indirect),_indirectCommand(0) {}

        DrawElementsIndirect(const DrawElementsIndirect& rhs,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            DrawElements(rhs,copyop) {_indirectCommand=rhs._indirectCommand;}

        void setIndirectOffset( void * i){_indirect=i;}
        void * getIndirectOffset()const{return _indirect;}

        inline void setIndirectCommand(DrawElementsIndirectCommand*idc){_indirectCommand = idc;    if(!_indirectCommand->getBufferObject())
        _indirectCommand->setBufferObject(new osg::VertexBufferObject());}
        inline DrawElementsIndirectCommand* getIndirectCommand()const{return _indirectCommand;}
    protected:
        virtual ~DrawElementsIndirect() {}
        void *  _indirect;
        ref_ptr<DrawElementsIndirectCommand> _indirectCommand;
};
class OSG_EXPORT DrawElementsIndirectUByte : public DrawElementsIndirect, public VectorGLubyte
{
    public:

        typedef VectorGLubyte vector_type;

        DrawElementsIndirectUByte(GLenum mode=0):
            DrawElementsIndirect(DrawElementsUByteIndirectPrimitiveType,mode) {}

        DrawElementsIndirectUByte(const DrawElementsIndirectUByte& array, const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            DrawElementsIndirect(array,copyop),
            vector_type(array) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         * \param ptr Pointer to a GLubyte to copy index data from.
         * \param numInstances When non zero passed as the number of draw instances to use re.
         */
        DrawElementsIndirectUByte(GLenum mode, unsigned int no, const GLubyte* ptr) :
            DrawElementsIndirect(DrawElementsUByteIndirectPrimitiveType,mode),
            vector_type(ptr,ptr+no) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         */
        DrawElementsIndirectUByte(GLenum mode, unsigned int no) :
            DrawElementsIndirect(DrawElementsUByteIndirectPrimitiveType,mode),
            vector_type(no) {}

        virtual Object* cloneType() const { return new DrawElementsIndirectUByte(); }
        virtual Object* clone(const CopyOp& copyop) const { return new DrawElementsIndirectUByte(*this,copyop); }
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawElementsIndirectUByte*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "DrawElementsIndirectUByte"; }

        virtual const GLvoid*   getDataPointer() const { return empty()?0:&front(); }
        virtual unsigned int    getTotalDataSize() const { return static_cast<unsigned int>(size()); }
        virtual bool            supportsBufferObject() const { return false; }

        virtual void draw(State& state, bool useVertexBufferObjects, bool bindElementBuffer=true) const;

        virtual void accept(PrimitiveFunctor& functor) const;
        virtual void accept(PrimitiveIndexFunctor& functor) const;

        virtual unsigned int getNumIndices() const { return static_cast<unsigned int>(size()); }
        virtual unsigned int index(unsigned int pos) const { return (*this)[pos]; }
        virtual void offsetIndices(int offset);

        virtual GLenum getDataType() { return GL_UNSIGNED_BYTE; }
        virtual void resizeElements(unsigned int numIndices) { resize(numIndices); }
        virtual void reserveElements(unsigned int numIndices) { reserve(numIndices); }
        virtual void setElement(unsigned int i, unsigned int v)  { (*this)[i] = v; }
        virtual unsigned int getElement(unsigned int i) { return (*this)[i]; }
        virtual void addElement(unsigned int v) { push_back(GLubyte(v)); }

    protected:

        virtual ~DrawElementsIndirectUByte();
};


class OSG_EXPORT DrawElementsIndirectUShort : public DrawElementsIndirect, public VectorGLushort
{
    public:

        typedef VectorGLushort vector_type;

        DrawElementsIndirectUShort(GLenum mode=0):
            DrawElementsIndirect(DrawElementsUShortIndirectPrimitiveType,mode) {}

        DrawElementsIndirectUShort(const DrawElementsIndirectUShort& array,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            DrawElementsIndirect(array,copyop),
            vector_type(array) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         * \param ptr Pointer to a GLushort to copy index data from.
         * \param numInstances When non zero passed as the number of draw instances to use re.
         */
        DrawElementsIndirectUShort(GLenum mode, unsigned int no, const GLushort* ptr) :
            DrawElementsIndirect(DrawElementsUShortIndirectPrimitiveType,mode),
            vector_type(ptr,ptr+no) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         */
        DrawElementsIndirectUShort(GLenum mode, unsigned int no) :
            DrawElementsIndirect(DrawElementsUShortIndirectPrimitiveType,mode),
            vector_type(no) {}

        template <class InputIterator>
        DrawElementsIndirectUShort(GLenum mode, InputIterator first,InputIterator last) :
            DrawElementsIndirect(DrawElementsUShortIndirectPrimitiveType,mode),
            vector_type(first,last) {}

        virtual Object* cloneType() const { return new DrawElementsIndirectUShort(); }
        virtual Object* clone(const CopyOp& copyop) const { return new DrawElementsIndirectUShort(*this,copyop); }
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawElementsIndirectUShort*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "DrawElementsIndirectUShort"; }

        virtual const GLvoid*   getDataPointer() const { return empty()?0:&front(); }
        virtual unsigned int    getTotalDataSize() const { return 2u*static_cast<unsigned int>(size()); }
        virtual bool            supportsBufferObject() const { return false; }

        virtual void draw(State& state, bool useVertexBufferObjects, bool bindElementBuffer=true) const;

        virtual void accept(PrimitiveFunctor& functor) const;
        virtual void accept(PrimitiveIndexFunctor& functor) const;

        virtual unsigned int getNumIndices() const { return static_cast<unsigned int>(size()); }
        virtual unsigned int index(unsigned int pos) const { return (*this)[pos]; }
        virtual void offsetIndices(int offset);

        virtual GLenum getDataType() { return GL_UNSIGNED_SHORT; }
        virtual void resizeElements(unsigned int numIndices) { resize(numIndices); }
        virtual void reserveElements(unsigned int numIndices) { reserve(numIndices); }
        virtual void setElement(unsigned int i, unsigned int v) { (*this)[i] = v; }
        virtual unsigned int getElement(unsigned int i) { return (*this)[i]; }
        virtual void addElement(unsigned int v) { push_back(GLushort(v)); }

    protected:

        virtual ~DrawElementsIndirectUShort();
};

class OSG_EXPORT DrawElementsIndirectUInt : public DrawElementsIndirect, public VectorGLuint
{
    public:

        typedef VectorGLuint vector_type;

        DrawElementsIndirectUInt(GLenum mode=0):
            DrawElementsIndirect(DrawElementsUIntIndirectPrimitiveType,mode) {}

        DrawElementsIndirectUInt(const DrawElementsIndirectUInt& array,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
            DrawElementsIndirect(array,copyop),
            vector_type(array) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         * \param ptr Pointer to a GLuint to copy index data from.
         * \param numInstances When non zero passed as the number of draw instances to use re.
         */
        DrawElementsIndirectUInt(GLenum mode, unsigned int no, const GLuint* ptr) :
            DrawElementsIndirect(DrawElementsUIntIndirectPrimitiveType,mode),
            vector_type(ptr,ptr+no) {}

        /**
         * \param mode One of osg::PrimitiveSet::Mode. Determines the type of primitives used.
         * \param no Number of intended elements. This will be the size of the underlying vector.
         */
        DrawElementsIndirectUInt(GLenum mode, unsigned int no) :
            DrawElementsIndirect(DrawElementsUIntIndirectPrimitiveType,mode),
            vector_type(no) {}

        template <class InputIterator>
        DrawElementsIndirectUInt(GLenum mode, InputIterator first,InputIterator last) :
            DrawElementsIndirect(DrawElementsUIntIndirectPrimitiveType,mode),
            vector_type(first,last) {}

        virtual Object* cloneType() const { return new DrawElementsIndirectUInt(); }
        virtual Object* clone(const CopyOp& copyop) const { return new DrawElementsIndirectUInt(*this,copyop); }
        virtual bool isSameKindAs(const Object* obj) const { return dynamic_cast<const DrawElementsIndirectUInt*>(obj)!=NULL; }
        virtual const char* libraryName() const { return "osg"; }
        virtual const char* className() const { return "DrawElementsIndirectUInt"; }

        virtual const GLvoid*   getDataPointer() const { return empty()?0:&front(); }
        virtual unsigned int    getTotalDataSize() const { return 4u*static_cast<unsigned int>(size()); }
        virtual bool            supportsBufferObject() const { return false; }

        virtual void draw(State& state, bool useVertexBufferObjects, bool bindElementBuffer=true) const;

        virtual void accept(PrimitiveFunctor& functor) const;
        virtual void accept(PrimitiveIndexFunctor& functor) const;

        virtual unsigned int getNumIndices() const { return static_cast<unsigned int>(size()); }
        virtual unsigned int index(unsigned int pos) const { return (*this)[pos]; }
        virtual void offsetIndices(int offset);

        virtual GLenum getDataType() { return GL_UNSIGNED_INT; }
        virtual void resizeElements(unsigned int numIndices) { resize(numIndices); }
        virtual void reserveElements(unsigned int numIndices) { reserve(numIndices); }
        virtual void setElement(unsigned int i, unsigned int v) { (*this)[i] = v; }
        virtual unsigned int getElement(unsigned int i) { return (*this)[i]; }
        virtual void addElement(unsigned int v) { push_back(GLuint(v)); }

    protected:

        virtual ~DrawElementsIndirectUInt();
};

#ifdef OSG_HAS_MULTIDRAWARRAYS
class OSG_EXPORT MultiDrawArraysIndirect : public osg::PrimitiveSet
{
public:

    MultiDrawArraysIndirect(GLenum mode=0, void * indirect=0, GLsizei drawcount=0, GLsizei stride=0):
        osg::PrimitiveSet(Type(MultiDrawArraysPrimitiveType), mode), _indirect(indirect), _drawcount(drawcount), _stride(stride) {}

    MultiDrawArraysIndirect(const MultiDrawArraysIndirect& dal,const CopyOp& copyop=CopyOp::SHALLOW_COPY):
        osg::PrimitiveSet(dal,copyop),
        /*_firsts(dal._firsts),
        _counts(dal._counts) */
        _indirect(dal._indirect),
        _drawcount(dal._drawcount),
        _stride(dal._stride)
        {}

    virtual osg::Object* cloneType() const { return new MultiDrawArraysIndirect(); }
    virtual osg::Object* clone(const osg::CopyOp& copyop) const { return new MultiDrawArraysIndirect(*this,copyop); }
    virtual bool isSameKindAs(const osg::Object* obj) const { return dynamic_cast<const MultiDrawArraysIndirect*>(obj)!=NULL; }
    virtual const char* libraryName() const { return "osg"; }
    virtual const char* className() const { return "MultiDrawArraysIndirect"; }


    virtual void draw(State& state, bool useVertexBufferObjects, bool bindElementBuffer=true) const;

    virtual void accept(PrimitiveFunctor& functor) const;
    virtual void accept(PrimitiveIndexFunctor& functor) const;

    virtual unsigned int getNumIndices() const;
    virtual unsigned int index(unsigned int pos) const;
    virtual void offsetIndices(int offset);

    virtual unsigned int getNumPrimitives() const;

    /*typedef std::vector<GLint> Firsts;
    void setFirsts(const Firsts& firsts) { _firsts = firsts; }
    Firsts& getFirsts() { return _firsts; }
    const Firsts& getFirsts() const { return _firsts; }

    typedef std::vector<GLsizei> Counts;
    void setCounts(const Counts& firsts) { _counts = firsts; }
    Counts& getCounts() { return _counts; }
    const Counts& getCounts() const { return _counts; }

    void add(GLint first, GLsizei count);*/

    void setIndirectOffset( void * i){_indirect=i;}
    void * getIndirectOffset()const{return _indirect;}

    void setStride( GLsizei  i){_stride=i;}
    GLsizei getStride()const{return _stride;}
    void setDrawCount( GLsizei  i){_drawcount=i;}
    GLsizei getDrawCount()const{return _drawcount;}
       inline void setIndirectCommand(DrawArraysIndirectCommand*idc){_indirectCommand = idc;    if(!_indirectCommand->getBufferObject())
        _indirectCommand->setBufferObject(new osg::VertexBufferObject());}
        inline DrawArraysIndirectCommand* getIndirectCommand()const{return _indirectCommand;}


protected:

 //   Firsts _firsts;
 //   Counts _counts;
    void * _indirect;
    GLsizei _drawcount, _stride;
        ref_ptr<DrawArraysIndirectCommand> _indirectCommand;

};
#endif


}

#endif
