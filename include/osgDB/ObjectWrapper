/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2010 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/
// Written by Wang Rui, (C) 2010

#ifndef OSGDB_OBJECTWRAPPER
#define OSGDB_OBJECTWRAPPER

#include <OpenThreads/ReentrantMutex>
#include <osgDB/Serializer>
#include <osg/ScriptEngine>

namespace osgDB
{

struct MethodObject : public osg::Referenced
{
    typedef std::vector< osg::ref_ptr<osg::Object> > Parameters;

    virtual bool run(void* objectPtr, osg::Parameters& inputParameters, osg::Parameters& outputParameters) const = 0;

    virtual ~MethodObject() {}
};

class OSGDB_EXPORT BaseCompressor : public osg::Referenced
{
public:
    BaseCompressor() {}
    void setName( const std::string& name ) { _name = name; }
    const std::string& getName() const { return _name; }

    virtual bool compress( std::ostream&, const std::string& ) = 0;
    virtual bool decompress( std::istream&, std::string& ) = 0;

protected:
    std::string _name;
};

struct FinishedObjectReadCallback : public osg::Referenced
{
    virtual void objectRead(osgDB::InputStream& is, osg::Object& obj) = 0;
};

struct OSGDB_EXPORT ObjectWrapperAssociate
{
    ObjectWrapperAssociate(std::string name):_firstVersion(0),_lastVersion(INT_MAX),_name(name){}
    int _firstVersion;
    int _lastVersion;
    std::string _name;
};

class OSGDB_EXPORT ObjectWrapper : public osg::Referenced
{
public:
    typedef std::vector< BaseSerializer::Type > TypeList;
    typedef std::vector< osg::ref_ptr<BaseSerializer> > SerializerList;
    typedef std::vector< osg::ref_ptr<FinishedObjectReadCallback> > FinishedObjectReadCallbackList;
    typedef std::list<ObjectWrapperAssociate>  RevisionAssociateList;
    typedef osg::Object* CreateInstanceFunc();

    ObjectWrapper( CreateInstanceFunc* createInstanceFunc, const std::string& name,
                   const std::string& associates );
    ObjectWrapper( CreateInstanceFunc* createInstanceFunc, const std::string& domain, const std::string& name,
                   const std::string& associates );

    void setUpdatedVersion( int ver ) { _version = ver; }
    int getUpdatedVersion() const { return _version; }

    osg::Object* createInstance() const { return  _createInstanceFunc(); }
    const std::string& getDomain() const { return _domain; }
    const std::string& getName() const { return _name; }

    const RevisionAssociateList& getAssociates() const { return _associates; }

    SerializerList& getSerializerList() { return _serializers; }
    const SerializerList& getSerializerList() const { return _serializers; }

    TypeList& getTypeList() { return _typeList; }
    const TypeList& getTypeList() const { return _typeList; }

    void addSerializer( BaseSerializer* s, BaseSerializer::Type t=BaseSerializer::RW_UNDEFINED );
    void markSerializerAsRemoved( const std::string& name );

    void markAssociateAsRemoved(const std::string& name);
    void markAssociateAsAdded(const std::string& name);

    BaseSerializer* getLastSerializer() { return _serializers.empty() ? 0 : _serializers.back().get(); }
    BaseSerializer* getSerializer( const std::string& name );
    BaseSerializer* getSerializer( const std::string& name, BaseSerializer::Type& type);

    void addFinishedObjectReadCallback ( FinishedObjectReadCallback* forc) { _finishedObjectReadCallbacks.push_back(forc); }

    bool read( InputStream&, osg::Object& );
    bool write( OutputStream&, const osg::Object& );

    bool readSchema( const StringList& properties, const TypeList& types );
    void writeSchema( StringList& properties, TypeList& types );
    void resetSchema() { if ( _backupSerializers.size()>0 ) _serializers = _backupSerializers; }

    void addMethodObject(const std::string& methodName, MethodObject* mo);

    typedef std::multimap< std::string, osg::ref_ptr<MethodObject> > MethodObjectMap;

    MethodObjectMap& getMethodObjectMap() { return _methodObjectMap; }
    const MethodObjectMap& getMethodObjectMap() const { return _methodObjectMap; }

    void setupAssociatesRevisionsInheritanceIfRequired();

protected:
    ObjectWrapper() : _version(0) {}
    virtual ~ObjectWrapper() {}

    CreateInstanceFunc* _createInstanceFunc;
    std::string _domain;
    std::string _name;
    RevisionAssociateList _associates;
    SerializerList _serializers;
    SerializerList _backupSerializers;
    TypeList _typeList;
    FinishedObjectReadCallbackList _finishedObjectReadCallbacks;
    MethodObjectMap _methodObjectMap;
    int _version;  // Last updated version of the wrapper
    //simulate associate revisions inheritance
    bool _isAssociatesRevisionsInheritanceDone;
    static void splitAssociates( const std::string& src, ObjectWrapper::RevisionAssociateList& list, char separator=' ' );
};

struct UpdateWrapperVersionProxy
{
    UpdateWrapperVersionProxy( ObjectWrapper* w, int v ): _wrapper(w)
    {
        _lastVersion = w->getUpdatedVersion();
        w->setUpdatedVersion(v);
    }

    ~UpdateWrapperVersionProxy()
    {
        _wrapper->setUpdatedVersion(_lastVersion);
    }

    ObjectWrapper* _wrapper;
    int _lastVersion;
};

class Registry;

class OSGDB_EXPORT ObjectWrapperManager : public osg::Referenced
{
public:

    // Wrapper handlers
    void addWrapper( ObjectWrapper* wrapper );
    void removeWrapper( ObjectWrapper* wrapper );
    ObjectWrapper* findWrapper( const std::string& name );

    typedef std::map< std::string, osg::ref_ptr<ObjectWrapper> > WrapperMap;
    WrapperMap& getWrapperMap() { return _wrappers; }
    const WrapperMap& getWrapperMap() const { return _wrappers; }

    // Compressor handlers
    void addCompressor( BaseCompressor* compressor );
    void removeCompressor( BaseCompressor* compressor );
    BaseCompressor* findCompressor( const std::string& name );

    typedef std::map< std::string, osg::ref_ptr<BaseCompressor> > CompressorMap;
    CompressorMap& getCompressorMap() { return _compressors; }
    const CompressorMap& getCompressorMap() const { return _compressors; }

    typedef std::map<std::string, IntLookup> IntLookupMap;
    IntLookup::Value getValue( const std::string& group, const std::string& str ) { return findLookup(group).getValue(str.c_str()); }
    const std::string& getString( const std::string& group, IntLookup::Value value ) { return findLookup(group).getString(value); }

    IntLookupMap& getLookupMap() { return _globalMap; }
    const IntLookupMap& getLookupMap() const { return _globalMap; }

protected:

    friend class osgDB::Registry;

    ObjectWrapperManager();
    virtual ~ObjectWrapperManager();

    OpenThreads::ReentrantMutex _wrapperMutex;

    WrapperMap _wrappers;
    CompressorMap _compressors;

    IntLookup& findLookup( const std::string& group )
    {
        IntLookupMap::iterator itr = _globalMap.find(group);
        if ( itr!=_globalMap.end() ) return itr->second;
        else return _globalMap["GL"];
    }

    IntLookupMap _globalMap;
};


class OSGDB_EXPORT RegisterWrapperProxy
{
public:
    typedef void (*AddPropFunc)( ObjectWrapper* );

    RegisterWrapperProxy( ObjectWrapper::CreateInstanceFunc *createInstanceFunc, const std::string& name,
                          const std::string& associates, AddPropFunc func );

    virtual ~RegisterWrapperProxy();

protected:
    osg::ref_ptr<ObjectWrapper> _wrapper;
};

class OSGDB_EXPORT RegisterCustomWrapperProxy
{
public:
    typedef void (*AddPropFunc)( const char*, ObjectWrapper* );

    RegisterCustomWrapperProxy( ObjectWrapper::CreateInstanceFunc *createInstanceFunc, const std::string& domain, const std::string& name,
                                const std::string& associates, AddPropFunc func );

    virtual ~RegisterCustomWrapperProxy();

protected:
    osg::ref_ptr<ObjectWrapper> _wrapper;
};

#define REGISTER_OBJECT_WRAPPER(NAME, CREATEINSTANCE, CLASS, ASSOCIATES) \
    extern "C" void wrapper_serializer_##NAME(void) {} \
    extern void wrapper_propfunc_##NAME(osgDB::ObjectWrapper*); \
    static osg::Object* wrapper_createinstancefunc##NAME() { return CREATEINSTANCE; } \
    static osgDB::RegisterWrapperProxy wrapper_proxy_##NAME( \
        wrapper_createinstancefunc##NAME, #CLASS, ASSOCIATES, &wrapper_propfunc_##NAME); \
    typedef CLASS MyClass; \
    void wrapper_propfunc_##NAME(osgDB::ObjectWrapper* wrapper)

#define REGISTER_OBJECT_WRAPPER2(NAME, CREATEINSTANCE, CLASS, CLASSNAME, ASSOCIATES) \
    extern "C" void wrapper_serializer_##NAME(void) {} \
    extern void wrapper_propfunc_##NAME(osgDB::ObjectWrapper*); \
    static osg::Object* wrapper_createinstancefunc##NAME() { return CREATEINSTANCE; } \
    static osgDB::RegisterWrapperProxy wrapper_proxy_##NAME( \
        wrapper_createinstancefunc##NAME, CLASSNAME, ASSOCIATES, &wrapper_propfunc_##NAME); \
    typedef CLASS MyClass; \
    void wrapper_propfunc_##NAME(osgDB::ObjectWrapper* wrapper)

#define REGISTER_CUSTOM_OBJECT_WRAPPER(DOMAIN, NAME, CREATEINSTANCE, CLASS, ASSOCIATES) \
    extern "C" void wrapper_serializer_##NAME(void) {} \
    extern void wrapper_propfunc_##NAME(const char*, osgDB::ObjectWrapper*); \
    static osg::Object* wrapper_createinstancefunc##NAME() { return CREATEINSTANCE; } \
    static osgDB::RegisterCustomWrapperProxy wrapper_proxy_##NAME( \
        wrapper_createinstancefunc##NAME, #DOMAIN, #CLASS, ASSOCIATES, &wrapper_propfunc_##NAME); \
    typedef CLASS MyClass; \
    void wrapper_propfunc_##NAME(const char* domain, osgDB::ObjectWrapper* wrapper)

#define REGISTER_CUSTOM_OBJECT_WRAPPER2(DOMAIN, NAME, CREATEINSTANCE, CLASS, CLASSNAME, ASSOCIATES) \
    extern "C" void wrapper_serializer_##NAME(void) {} \
    extern void wrapper_propfunc_##NAME(const char*, osgDB::ObjectWrapper*); \
    static osg::Object* wrapper_createinstancefunc##NAME() { return CREATEINSTANCE; } \
    static osgDB::RegisterCustomWrapperProxy wrapper_proxy_##NAME( \
        wrapper_createinstancefunc##NAME, #DOMAIN, CLASSNAME, ASSOCIATES, &wrapper_propfunc_##NAME); \
    typedef CLASS MyClass; \
    void wrapper_propfunc_##NAME(const char* domain, osgDB::ObjectWrapper* wrapper)

class OSGDB_EXPORT RegisterCompressorProxy
{
public:
    RegisterCompressorProxy( const std::string& name, BaseCompressor* compressor );
    ~RegisterCompressorProxy();

protected:
    osg::ref_ptr<BaseCompressor> _compressor;
};

#define REGISTER_COMPRESSOR(NAME, CLASS) \
    extern "C" void wrapper_compressor_##CLASS(void) {} \
    static osgDB::RegisterCompressorProxy compressor_proxy_##CLASS(NAME, new CLASS);

/** Method wrapping helpers **/
template <class T>
class ObjectParameter{
    T* _t;
public:
    inline void set(T* t)          {         _t=t;                                   }
    inline void set(osg::Object* t){         _t=OBJECT_CAST<T*>(t);                  }
    inline T* get()                {         return _t;                              }
    inline osg::Object *getObject(){         return  get();                          }
    inline osg::Object *getNew()   {         return get();                           }
};

template <class T,class U>
class ValueObjectParameter{
    T _t; osg::ref_ptr<osg::ValueObject> _u;
public:
    inline void set(T t)            {        _t=t;                                    }
    inline void set(osg::Object * u){        _u=static_cast<osg::ValueObject*>(u);    }
    inline osg::Object *getNew()    {        _u= new U("return",_t);return _u.get();  }
    inline osg::Object *getObject() {        return _u.get();                         }
    inline  T get(){
        T ret;
        osg::DoubleValueObject* dvo = dynamic_cast<osg::DoubleValueObject*>(_u.get());
        if (dvo) ret= dvo->getValue();
        else ret= static_cast<U*>(_u.get())->getValue();
        return ret;
    }
};

typedef ValueObjectParameter<std::string,osg::StringValueObject> StringValueObjectParameter;
typedef ValueObjectParameter<bool,osg::BoolValueObject> BoolValueObjectParameter;
typedef ValueObjectParameter<char,osg::CharValueObject> CharValueObjectParameter;
typedef ValueObjectParameter<unsigned char,osg::UCharValueObject> UCharValueObjectParameter;
typedef ValueObjectParameter<short,osg::ShortValueObject> ShortValueObjectParameter;
typedef ValueObjectParameter<unsigned short,osg::UShortValueObject> UShortValueObjectParameter;
typedef ValueObjectParameter<int,osg::IntValueObject> IntValueObjectParameter;
typedef ValueObjectParameter<unsigned int,osg::UIntValueObject> UIntValueObjectParameter;
typedef ValueObjectParameter<float,osg::FloatValueObject> FloatValueObjectParameter;
typedef ValueObjectParameter<double,osg::DoubleValueObject> DoubleValueObjectParameter;
typedef ValueObjectParameter<osg::Vec2f,osg::Vec2fValueObject> Vec2fValueObjectParameter;
typedef ValueObjectParameter<osg::Vec3f,osg::Vec3fValueObject> Vec3fValueObjectParameter;
typedef ValueObjectParameter<osg::Vec4f,osg::Vec4fValueObject> Vec4fValueObjectParameter;
typedef ValueObjectParameter<osg::Vec2d,osg::Vec2dValueObject> Vec2dValueObjectParameter;
typedef ValueObjectParameter<osg::Vec3d,osg::Vec3dValueObject> Vec3dValueObjectParameter;
typedef ValueObjectParameter<osg::Vec4d,osg::Vec4dValueObject> Vec4dValueObjectParameter;
typedef ValueObjectParameter<osg::Quat,osg::QuatValueObject> QuatValueObjectParameter;
typedef ValueObjectParameter<osg::Plane,osg::PlaneValueObject> PlaneValueObjectParameter;
typedef ValueObjectParameter<osg::Matrixf,osg::MatrixfValueObject> MatrixfValueObjectParameter;
typedef ValueObjectParameter<osg::Matrixd,osg::MatrixdValueObject> MatrixdValueObjectParameter;
typedef ValueObjectParameter<osg::BoundingBoxf,osg::BoundingBoxfValueObject> BoundingBoxfValueObjectParameter;
typedef ValueObjectParameter<osg::BoundingBoxd,osg::BoundingBoxdValueObject> BoundingBoxdValueObjectParameter;
typedef ValueObjectParameter<osg::BoundingSpheref,osg::BoundingSpherefValueObject> BoundingSpherefValueObjectParameter;
typedef ValueObjectParameter<osg::BoundingSphered,osg::BoundingSpheredValueObject> BoundingSpheredValueObjectParameter;
}
#define BEGIN_METHOD_SERIALIZER(CLASS,WRAPMETHODNAME) \
struct wrap_##WRAPMETHODNAME : public osgDB::MethodObject{\
    virtual bool run(void* objectPtr, osg::Parameters& inputParameters, osg::Parameters& outputParameters) const {\
        CLASS* classobj = OBJECT_CAST<CLASS*>(objectPtr);
#define END_METHOD_SERIALIZER return true;}};

#define WRAP_METHOD_GET_RETURN(RETTYPE,XXX) \
    RETTYPE retobj;retobj.set(XXX);     if(!retobj.getObject())return false;\
    osg::Object *ret=retobj.getNew();    if(ret)outputParameters.push_back(ret);
#define WRAP_METHOD_GET_ARG(X,ARGTYPE) ARGTYPE arg##X;arg##X.set(inputParameters[X].get());   if(!arg##X.getObject())return false;

#define WRAP_RET_METHOD(RETTYPE, CLASS, GETTERMETHODNAME)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       WRAP_METHOD_GET_RETURN(RETTYPE,classobj->GETTERMETHODNAME()) \
END_METHOD_SERIALIZER

#define WRAP_VOID_METHOD(CLASS, GETTERMETHODNAME)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       classobj->GETTERMETHODNAME(); \
END_METHOD_SERIALIZER

#define WRAP_RET_1ARG_METHOD(RETTYPE, CLASS, GETTERMETHODNAME, ARG0)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       WRAP_METHOD_GET_ARG(0,ARG0) \
       WRAP_METHOD_GET_RETURN(RETTYPE,classobj->GETTERMETHODNAME(arg0.get())) \
END_METHOD_SERIALIZER

#define WRAP_VOID_1ARG_METHOD(CLASS, GETTERMETHODNAME, ARG0)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       WRAP_METHOD_GET_ARG(0,ARG0) \
       classobj->GETTERMETHODNAME(arg0.get()); \
END_METHOD_SERIALIZER

#define WRAP_RET_2ARG_METHOD(RETTYPE, CLASS, GETTERMETHODNAME, ARG0,ARG1)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
    WRAP_METHOD_GET_ARG(0,ARG0) WRAP_METHOD_GET_ARG(1,ARG1)  \
       WRAP_METHOD_GET_RETURN(RETTYPE,classobj->GETTERMETHODNAME(arg0.get(),arg1.get())) \
END_METHOD_SERIALIZER

#define WRAP_VOID_2ARG_METHOD( CLASS, GETTERMETHODNAME, ARG0,ARG1)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       WRAP_METHOD_GET_ARG(0,ARG0) \WRAP_METHOD_GET_ARG(1,ARG1) \
       classobj->GETTERMETHODNAME(arg0.get(),arg1.get()); \
END_METHOD_SERIALIZER

#define WRAP_RET_3ARG_METHOD(RETTYPE, CLASS, GETTERMETHODNAME, ARG0,ARG1,ARG2)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
    WRAP_METHOD_GET_ARG(0,ARG0) WRAP_METHOD_GET_ARG(1,ARG1)  WRAP_METHOD_GET_ARG(2,ARG2) \
       WRAP_METHOD_GET_RETURN(RETTYPE,classobj->GETTERMETHODNAME(arg0.get(),arg1.get(),arg2.get())) \
END_METHOD_SERIALIZER

#define WRAP_VOID_3ARG_METHOD(CLASS, GETTERMETHODNAME, ARG0,ARG1,ARG2)  \
BEGIN_METHOD_SERIALIZER(CLASS,GETTERMETHODNAME )\
       WRAP_METHOD_GET_ARG(0,ARG0) WRAP_METHOD_GET_ARG(1,ARG1)  WRAP_METHOD_GET_ARG(2,ARG2) \
       classobj->GETTERMETHODNAME(arg0.get(),arg1.get(),arg2.get()); \
END_METHOD_SERIALIZER

#endif
