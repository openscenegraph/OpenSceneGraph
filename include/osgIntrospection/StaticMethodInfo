/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2005 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/
//osgIntrospection - Copyright (C) 2005 Marco Jez

#ifndef OSGINTROSPECTION_STATICMETHODINFO_
#define OSGINTROSPECTION_STATICMETHODINFO_

#include <osgIntrospection/MethodInfo>
#include <osgIntrospection/Reflection>
#include <osgIntrospection/Utility>

namespace osgIntrospection
{

    /// Class templates StaticMethodInfoN (where 0 <= N <= 16) are concrete 
    /// implementations of MethodInfo. They are used to keep information
    /// about static class methods and to provide the means for calling them
    /// dynamically. Each class template can handle methods with N arguments 
    /// and is parametrized by the class that declares the method and by the 
    /// return type. Both const and non-const methods are supported.
    /// The invoke() methods allow to call the reflected method dynamically,
    /// passing it the arguments as a list of Value objects.
    ///
    template<typename C, typename R> 
    class StaticMethodInfo0: public MethodInfo
    {
    public:
        typedef R (*FunctionType)();

        StaticMethodInfo0(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList&  /*args*/) const
        {

            if (f_) return (*f_)();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0> 
    class StaticMethodInfo1: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0);

        StaticMethodInfo1(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(1);
            convertArgument<P0>(args, newargs, getParameters(), 0);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1> 
    class StaticMethodInfo2: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1);

        StaticMethodInfo2(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(2);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2> 
    class StaticMethodInfo3: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2);

        StaticMethodInfo3(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(3);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3> 
    class StaticMethodInfo4: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3);

        StaticMethodInfo4(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(4);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4> 
    class StaticMethodInfo5: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4);

        StaticMethodInfo5(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(5);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5> 
    class StaticMethodInfo6: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5);

        StaticMethodInfo6(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(6);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6> 
    class StaticMethodInfo7: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6);

        StaticMethodInfo7(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(7);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7> 
    class StaticMethodInfo8: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7);

        StaticMethodInfo8(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(8);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8> 
    class StaticMethodInfo9: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8);

        StaticMethodInfo9(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(9);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9> 
    class StaticMethodInfo10: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9);

        StaticMethodInfo10(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(10);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10> 
    class StaticMethodInfo11: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        StaticMethodInfo11(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(11);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11> 
    class StaticMethodInfo12: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11);

        StaticMethodInfo12(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(12);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12> 
    class StaticMethodInfo13: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12);

        StaticMethodInfo13(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(13);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13> 
    class StaticMethodInfo14: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13);

        StaticMethodInfo14(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(14);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14> 
    class StaticMethodInfo15: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14);

        StaticMethodInfo15(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(15);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);
            convertArgument<P14>(args, newargs, getParameters(), 14);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13]), variant_cast<P14>(newargs[14]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15> 
    class StaticMethodInfo16: public MethodInfo
    {
    public:
        typedef R (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15);

        StaticMethodInfo16(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(R), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(16);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);
            convertArgument<P14>(args, newargs, getParameters(), 14);
            convertArgument<P15>(args, newargs, getParameters(), 15);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13]), variant_cast<P14>(newargs[14]), variant_cast<P15>(newargs[15]));
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C> 
    class StaticMethodInfo0<C, void>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)();

        StaticMethodInfo0(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList&  /*args*/) const
        {

            if (f_) return (*f_)(), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0> 
    class StaticMethodInfo1<C, void, P0>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0);

        StaticMethodInfo1(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(1);
            convertArgument<P0>(args, newargs, getParameters(), 0);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1> 
    class StaticMethodInfo2<C, void, P0, P1>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1);

        StaticMethodInfo2(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(2);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2> 
    class StaticMethodInfo3<C, void, P0, P1, P2>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2);

        StaticMethodInfo3(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(3);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3> 
    class StaticMethodInfo4<C, void, P0, P1, P2, P3>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3);

        StaticMethodInfo4(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(4);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4> 
    class StaticMethodInfo5<C, void, P0, P1, P2, P3, P4>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4);

        StaticMethodInfo5(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(5);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5> 
    class StaticMethodInfo6<C, void, P0, P1, P2, P3, P4, P5>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5);

        StaticMethodInfo6(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(6);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6> 
    class StaticMethodInfo7<C, void, P0, P1, P2, P3, P4, P5, P6>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6);

        StaticMethodInfo7(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(7);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7> 
    class StaticMethodInfo8<C, void, P0, P1, P2, P3, P4, P5, P6, P7>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7);

        StaticMethodInfo8(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(8);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8> 
    class StaticMethodInfo9<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8);

        StaticMethodInfo9(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(9);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9> 
    class StaticMethodInfo10<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9);

        StaticMethodInfo10(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(10);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10> 
    class StaticMethodInfo11<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        StaticMethodInfo11(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(11);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11> 
    class StaticMethodInfo12<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11);

        StaticMethodInfo12(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(12);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12> 
    class StaticMethodInfo13<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12);

        StaticMethodInfo13(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(13);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13> 
    class StaticMethodInfo14<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13);

        StaticMethodInfo14(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(14);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14> 
    class StaticMethodInfo15<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14);

        StaticMethodInfo15(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(15);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);
            convertArgument<P14>(args, newargs, getParameters(), 14);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13]), variant_cast<P14>(newargs[14])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };


    template<typename C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15> 
    class StaticMethodInfo16<C, void, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>: public MethodInfo
    {
    public:
        typedef void (*FunctionType)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15);

        StaticMethodInfo16(const std::string& qname, FunctionType f, const ParameterInfoList& plist)
        :    MethodInfo(qname, typeof(C), typeof(void), plist), f_(f)
        {
        }

        bool isConst() const { return false; }
        bool isStatic() const { return true; }

        Value invoke(ValueList& args) const
        {
            ValueList newargs(16);
            convertArgument<P0>(args, newargs, getParameters(), 0);
            convertArgument<P1>(args, newargs, getParameters(), 1);
            convertArgument<P2>(args, newargs, getParameters(), 2);
            convertArgument<P3>(args, newargs, getParameters(), 3);
            convertArgument<P4>(args, newargs, getParameters(), 4);
            convertArgument<P5>(args, newargs, getParameters(), 5);
            convertArgument<P6>(args, newargs, getParameters(), 6);
            convertArgument<P7>(args, newargs, getParameters(), 7);
            convertArgument<P8>(args, newargs, getParameters(), 8);
            convertArgument<P9>(args, newargs, getParameters(), 9);
            convertArgument<P10>(args, newargs, getParameters(), 10);
            convertArgument<P11>(args, newargs, getParameters(), 11);
            convertArgument<P12>(args, newargs, getParameters(), 12);
            convertArgument<P13>(args, newargs, getParameters(), 13);
            convertArgument<P14>(args, newargs, getParameters(), 14);
            convertArgument<P15>(args, newargs, getParameters(), 15);

            if (f_) return (*f_)(variant_cast<P0>(newargs[0]), variant_cast<P1>(newargs[1]), variant_cast<P2>(newargs[2]), variant_cast<P3>(newargs[3]), variant_cast<P4>(newargs[4]), variant_cast<P5>(newargs[5]), variant_cast<P6>(newargs[6]), variant_cast<P7>(newargs[7]), variant_cast<P8>(newargs[8]), variant_cast<P9>(newargs[9]), variant_cast<P10>(newargs[10]), variant_cast<P11>(newargs[11]), variant_cast<P12>(newargs[12]), variant_cast<P13>(newargs[13]), variant_cast<P14>(newargs[14]), variant_cast<P15>(newargs[15])), Value();
            throw InvalidFunctionPointerException();
        }

    private:
        FunctionType f_;
    };

}

#endif
