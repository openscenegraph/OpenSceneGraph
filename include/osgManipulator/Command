/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/
//osgManipulator - Copyright (C) 2007 Fugro-Jason B.V.

#ifndef OSGMANIPULATOR_COMMAND
#define OSGMANIPULATOR_COMMAND 1

#include <osgManipulator/Export>
#include <osgManipulator/Selection>

#include <osg/LineSegment>
#include <osg/Plane>
#include <osg/Vec2>

#include <vector>

namespace osgManipulator {

class Constraint;

/** Base class for motion commands that are generated by draggers. */
class OSGMANIPULATOR_EXPORT MotionCommand : public osg::Referenced
{
    public:

        /**
         * Motion command are based on click-drag-release actions. So each
         * command needs to indicate which stage of the motion the command
         * represents.
         */
        enum Stage
        {
            NONE,
            /** Click or pick start. */
            START,  
            /** Drag or pick move. */
            MOVE,
            /** Release or pick finish. */
            FINISH
        };

        MotionCommand();

        /** Execute the command. */
        virtual bool execute() = 0;

        /** Undo the command. The inverse of this command is executed. */
        virtual bool unexecute() = 0;

        /** Apply a constraint to the command. */
        virtual void applyConstraint(const Constraint*) = 0;

        /**
         * Add Selection (receiver) to the command. The command will be 
         * executed on all the selections. 
         */
        void addSelection(Selection*);

        /** Remove Selection (receiver) from the command. */
        void removeSelection(Selection*);

        /**
         * Gets the matrix for transforming the Selection. This matrix is in the
         * command's coordinate systems. 
         */
        virtual osg::Matrix getMotionMatrix() const = 0;

        /**
         * Sets the matrix for transforming the command's local coordinate
         * system to the world/object coordinate system.
         */
        void setLocalToWorldAndWorldToLocal(const osg::Matrix& localToWorld, const osg::Matrix& worldToLocal)
        {
            _localToWorld = localToWorld;
            _worldToLocal = worldToLocal;
        }

        /**
         * Gets the matrix for transforming the command's local coordinate
         * system to the world/object coordinate system.
         */
        inline const osg::Matrix& getLocalToWorld() const { return _localToWorld; }

        /**
         * Gets the matrix for transforming the command's world/object
         * coordinate system to the command's local coordinate system. 
         */
        inline const osg::Matrix& getWorldToLocal() const { return _worldToLocal; }

        void setStage(const Stage s) { _stage = s; }
        Stage getStage() const { return _stage; }

    protected:

        virtual ~MotionCommand();
        typedef std::vector< osg::ref_ptr<Selection> > SelectionList;

        SelectionList&       getSelectionList()       { return _selectionList; }
        const SelectionList& getSelectionList() const { return _selectionList; }
        
    private:
        osg::Matrix     _localToWorld;
        osg::Matrix     _worldToLocal;

        Stage           _stage;

        SelectionList        _selectionList;
};


/**
 * Command for translating in a line.
 */
class OSGMANIPULATOR_EXPORT TranslateInLineCommand : public MotionCommand
{
    public:

        TranslateInLineCommand();

        TranslateInLineCommand(const osg::LineSegment::vec_type& s, const osg::LineSegment::vec_type& e);

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setLine(const osg::LineSegment::vec_type& s, const osg::LineSegment::vec_type& e) { _line->start() = s; _line->end() = e; }
        inline const osg::LineSegment::vec_type& getLineStart() const { return _line->start(); }
        inline const osg::LineSegment::vec_type& getLineEnd() const { return _line->end(); }

        inline void setTranslation(const osg::Vec3& t) { _translation = t; }
        inline const osg::Vec3& getTranslation() const { return _translation; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return osg::Matrix::translate(_translation);
        }

    protected:

        virtual ~TranslateInLineCommand();

    private:
        osg::ref_ptr<osg::LineSegment>  _line;
        osg::Vec3                       _translation;
};

/**
 * Command for translating in a plane.
 */
class OSGMANIPULATOR_EXPORT TranslateInPlaneCommand : public MotionCommand
{
    public:

        TranslateInPlaneCommand();

        TranslateInPlaneCommand(const osg::Plane& plane);

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setPlane(const osg::Plane& plane) { _plane = plane; }
        inline const osg::Plane& getPlane() const { return _plane; }

        inline void setTranslation(const osg::Vec3& t) { _translation = t; }
        inline const osg::Vec3& getTranslation() const { return _translation; }

        /** ReferencePoint is used only for snapping. */
        inline void setReferencePoint(const osg::Vec3& rp) { _referencePoint = rp; }
        inline const osg::Vec3& getReferencePoint() const { return _referencePoint; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return osg::Matrix::translate(_translation);
        }

    protected:

        virtual ~TranslateInPlaneCommand();

    private:
        osg::Plane _plane;
        osg::Vec3  _translation;
        osg::Vec3  _referencePoint;
};

/**
 * Command for 1D scaling.
 */
class OSGMANIPULATOR_EXPORT Scale1DCommand : public MotionCommand
{
    public:

        Scale1DCommand();

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setScale(float s) { _scale = s; }
        inline float getScale() const { return _scale; }

        inline void  setScaleCenter(float center) { _scaleCenter = center; }
        inline float getScaleCenter() const       { return _scaleCenter; }

        /** ReferencePoint is used only for snapping. */
        inline void  setReferencePoint(float rp) { _referencePoint = rp; }
        inline float getReferencePoint() const   { return _referencePoint; }

        inline void  setMinScale(float min) { _minScale = min; }
        inline float getMinScale() const    { return _minScale; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return (osg::Matrix::translate(-_scaleCenter,0.0,0.0)
                    * osg::Matrix::scale(_scale,1.0,1.0)
                    * osg::Matrix::translate(_scaleCenter,0.0,0.0));
        }

    protected:

        virtual ~Scale1DCommand();

    private:
        float     _scale;
        float     _scaleCenter;
        float     _referencePoint;
        float     _minScale;
};

/**
 * Command for 2D scaling.
 */
class OSGMANIPULATOR_EXPORT Scale2DCommand : public MotionCommand
{
    public:

        Scale2DCommand();

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setScale(const osg::Vec2& s) { _scale = s; }
        inline const osg::Vec2& getScale() const { return _scale; }

        inline void setScaleCenter(const osg::Vec2& center) { _scaleCenter = center; }
        inline const osg::Vec2& getScaleCenter() const { return _scaleCenter; }

        /** ReferencePoint is used only for snapping. */
        inline void  setReferencePoint(const osg::Vec2& rp) { _referencePoint = rp; }
        inline const osg::Vec2& getReferencePoint() const   { return _referencePoint; }

        inline void             setMinScale(const osg::Vec2& min) { _minScale = min; }
        inline const osg::Vec2& getMinScale() const               { return _minScale; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return (osg::Matrix::translate(-_scaleCenter[0],0.0,-_scaleCenter[1])
                    * osg::Matrix::scale(_scale[0],1.0,_scale[1])
                    * osg::Matrix::translate(_scaleCenter[0],0.0,_scaleCenter[1]));
        }

    protected:

        virtual ~Scale2DCommand();

    private:
        osg::Vec2   _scale;
        osg::Vec2   _scaleCenter;
        osg::Vec2   _referencePoint;
        osg::Vec2   _minScale;
};

/**
 * Command for uniform 3D scaling.
 */
class OSGMANIPULATOR_EXPORT ScaleUniformCommand : public MotionCommand
{
    public:

        ScaleUniformCommand();

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setScale(float s) { _scale = s; }
        inline float getScale() const { return _scale; }

        inline void setScaleCenter(const osg::Vec3& center) { _scaleCenter = center; }
        inline const osg::Vec3& getScaleCenter() const { return _scaleCenter; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return (osg::Matrix::translate(-_scaleCenter) 
                    * osg::Matrix::scale(_scale,_scale,_scale)
                    * osg::Matrix::translate(_scaleCenter));
        }

    protected:

        virtual ~ScaleUniformCommand();

    private:
        float     _scale;
        osg::Vec3 _scaleCenter;
};

/**
 * Command for rotation in 3D.
 */
class OSGMANIPULATOR_EXPORT Rotate3DCommand : public MotionCommand
{
    public:

        Rotate3DCommand();

        virtual bool execute();
        virtual bool unexecute();
        virtual void applyConstraint(const Constraint*);

        inline void setRotation(const osg::Quat& rotation) { _rotation = rotation; }
        inline const osg::Quat& getRotation() const { return _rotation; }

        virtual osg::Matrix getMotionMatrix() const 
        {
            return osg::Matrix::rotate(_rotation);
        }

    protected:

        virtual ~Rotate3DCommand();

    private:
        osg::Quat _rotation;
};


}

#endif
