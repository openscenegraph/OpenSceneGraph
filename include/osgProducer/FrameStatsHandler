/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2003 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGPRODUCER_FRAME_STATS_HANDLER
#define OSGPRODUCER_FRAME_STATS_HANDLER 1

#include <Producer/CameraGroup>

#include <stdio.h>
#include <GL/gl.h>

namespace osgProducer {

class FrameStatsHandler : public Producer::CameraGroup::StatsHandler, public Producer::Camera::Callback
{
    public:
	FrameStatsHandler() 
	{
	    _fs.resize(6);
	    _index = 0;
	}

	void setArraySize(unsigned int size) { _fs.resize(size); }

	unsigned int getArraySize() { return _fs.size(); }

        void operator() (const Producer::CameraGroup &cg )
        {
	    _index = (_index + 1) % _fs.size();
            _fs[_index] = cg.getFrameStats();     
        }

	void operator() (const Producer::Camera &camera)
        {
            if (!camera.getInstrumentationMode()) return;

            int x,y;
            unsigned int width,height;
            camera.getProjectionRect(x,y,width,height);

	    glViewport( x, y, width, height );
            
	    // Set up the Orthographic view
	    glMatrixMode( GL_PROJECTION );
	    glPushMatrix();
	    glLoadIdentity();
	    glOrtho( -.01, .128, 600.0, -10.0, -1.0, 1.0 ); 

            glPushAttrib( GL_ENABLE_BIT );
	    glDisable( GL_LIGHTING );
	    glDisable( GL_DEPTH_TEST );
	    glEnable( GL_BLEND );

	    glMatrixMode( GL_MODELVIEW );
	    glPushMatrix();
	    glLoadIdentity();

            unsigned int lindex = (_index + 1) % _fs.size();
            Producer::Camera::TimeStamp zero = _fs[lindex]._startOfFrame;
            unsigned int i;
	    double x1=0.0, x2=0.0, y1=0.0, y2=0.0;
	    for(unsigned int frame = 0; frame < _fs.size(); frame++ )
	    {
		Producer::CameraGroup::FrameStats fs = _fs[(lindex + frame) % _fs.size()];
	        y1 = 0.0;
   	        y2 = y1 + 10;
	        x1 = fs._startOfUpdate - zero;
	        x2 = fs._endOfUpdate   - zero;

	        glBegin( GL_QUADS );

	        // Draw Update length
 	        glColor4f( 0.0, 1.0, 0.0, 0.5 );
	        glVertex2d( x1, y1);
	        glVertex2d( x2, y1);
	        glVertex2d( x2, y2);
	        glVertex2d( x1, y2);

	        for( i = 0; i < fs.getNumFrameTimeStampSets(); i++ )
                {
		    Producer::Camera::FrameTimeStampSet fts = fs.getFrameTimeStampSet(i);
	            y1 += 13.0;
	            y2 = y1 + 10.0;
	            x1 = fts[Producer::Camera::BeginCull] - zero;
	            x2 = fts[Producer::Camera::EndCull]   - zero;

 	            glColor4f( 0.0, 0.0, 1.0, 0.5 );
	            glVertex2d( x1, y1);
	            glVertex2d( x2, y1);
	            glVertex2d( x2, y2);
	            glVertex2d( x1, y2);

	            x1 = fts[Producer::Camera::BeginDraw] - zero;
	            x2 = fts[Producer::Camera::EndDraw]   - zero;

 	            glColor4f( 1.0, 0.0, 0.0, 0.5 );
	            glVertex2d( x1, y1);
	            glVertex2d( x2, y1);
	            glVertex2d( x2, y2);
	            glVertex2d( x1, y2);

                }
	        glEnd();

	        glBegin( GL_LINES );
	        glColor4f( 1, 1, 1, 0.5 );
	        glVertex2d( fs._startOfFrame - zero , 0.0 );
                y1 = fs.getNumFrameTimeStampSets() * 13.0 + 10.0;
                glVertex2d( fs._startOfFrame - zero, y1 );

                y1 = 12.5; 
	        for( i = 0; i < fs.getNumFrameTimeStampSets(); i++ )
                {
		    y2 = y1 + 11; 
		    Producer::Camera::FrameTimeStampSet fts = fs.getFrameTimeStampSet(i);
		    Producer::Camera::TimeStamp vsync = fts[Producer::Camera::Vsync];
		    double x1 = vsync - zero;
                    glColor4f( 1.0, 1.0, 0.0, 0.5 );
	            glVertex2d( x1, y1 );
                    glVertex2d( x1, y2 );
 		    y1 += 13.0;
  	        }
	 	glEnd();	
	    }

    	    glBegin( GL_LINES );

	    glColor4f( 1, 1, 1, 0.5 );
	    for( i = 0; i < 128; i++ )
            {
	        glVertex2d((GLdouble)i*.001, y1);

	       if( !(i%10) )
	           glVertex2d((GLdouble)i*.001, y1 - 5.0);
		else if( !(i%5) )
		    glVertex2d((GLdouble)i*.001, y1 - 3.0);
		else
		    glVertex2d((GLdouble)i*.001, y1 - 1.0);
	    }
           
	    glEnd();

	    glPopMatrix();
	    glMatrixMode( GL_PROJECTION );
	    glPopMatrix();
	    glMatrixMode( GL_MODELVIEW );

	    glPopAttrib();
        }

    private:
	std::vector <Producer::CameraGroup::FrameStats> _fs;
	unsigned int _index;
};

}

#endif
