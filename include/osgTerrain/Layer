/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
 *
 * This library is open source and may be redistributed and/or modified under  
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSGTERRAIN_LAYER
#define OSGTERRAIN_LAYER 1

#include <osg/Image>
#include <osg/Shape>
#include <osg/Array>
#include <osg/TransferFunction>

#include <osgTerrain/Locator>
#include <osgTerrain/ValidDataOperator>

namespace osgTerrain {

#define MAXIMUM_NUMBER_OF_LEVELS 30

class OSGTERRAIN_EXPORT Layer : public osg::Object
{
    public:

        Layer();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        Layer(const Layer&,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, Layer);
        
        /** Set the file name of the data associated with this layer. */
        virtual void setFileName(const std::string& filename) { _filename = filename; }

        /** Get the file name of the layer. */
        virtual const std::string& getFileName() const { return _filename; }
        

        void setLocator(Locator* locator) { _locator = locator; }
        Locator* getLocator() { return _locator.get(); }
        const Locator* getLocator() const { return _locator.get(); }
        
        void setMinLevel(unsigned int minLevel) { _minLevel = minLevel; }
        unsigned int getMinLevel() const { return _minLevel; }

        void setMaxLevel(unsigned int maxLevel) { _maxLevel = maxLevel; }
        unsigned int getMaxLevel() const { return _maxLevel; }

        void setValidDataOperator(ValidDataOperator* validDataOp) { _validDataOperator = validDataOp; }
        ValidDataOperator* getValidDataOperator() { return _validDataOperator.get(); }
        const ValidDataOperator* getValidDataOperator() const { return _validDataOperator.get(); }


        virtual unsigned int getNumColumns() const { return 0; }
        virtual unsigned int getNumRows() const { return 0; }

        void setDefaultValue(const osg::Vec4& value) { _defaultValue = value; }
        const osg::Vec4& getDefaultValue() const { return _defaultValue; }
        
        enum Filter
        {
            NEAREST,
            LINEAR
        };

        /** Set the texture filter to use when do texture associated with this layer.*/
        void setFilter(Filter filter) { _filter = filter; }

        /** Get the texture filter to use when do texture associated with this layer.*/
        Filter getFilter() const { return _filter; }


        /** Return image associated with layer if supported. */        
        virtual osg::Image* getImage() { return 0; }

        /** Return const image associated with layer if supported. */        
        virtual const osg::Image* getImage() const { return 0; }


        virtual bool transform(float offset, float scale) { return false; }


        virtual bool getValue(unsigned int /*i*/, unsigned int /*j*/, float& /*value*/) const { return false; }
        virtual bool getValue(unsigned int /*i*/, unsigned int /*j*/, osg::Vec2& /*value*/) const { return false; }
        virtual bool getValue(unsigned int /*i*/, unsigned int /*j*/, osg::Vec3& /*value*/) const { return false; }
        virtual bool getValue(unsigned int /*i*/, unsigned int /*j*/, osg::Vec4& /*value*/) const { return false; }

        inline bool getValidValue(unsigned int i, unsigned int j, float& value) const
        {
            if (getValue(i,j,value)) return _validDataOperator.valid() ? (*_validDataOperator)(value) : true;
            return false;
        }

        inline bool getValidValue(unsigned int i, unsigned int j, osg::Vec2& value) const
        {
            if (getValue(i,j,value)) return _validDataOperator.valid() ? (*_validDataOperator)(value) : true;
            return false;
        }

        inline bool getValidValue(unsigned int i, unsigned int j, osg::Vec3& value) const
        {
            if (getValue(i,j,value)) return _validDataOperator.valid() ? (*_validDataOperator)(value) : true;
            return false;
        }

        inline bool getValidValue(unsigned int i, unsigned int j, osg::Vec4& value) const
        {
            if (getValue(i,j,value)) return _validDataOperator.valid() ? (*_validDataOperator)(value) : true;
            return false;
        }


        inline void computeIndices(double ndc_x, double ndc_y, unsigned int& i, unsigned int& j, double& ir, double& jr)
        {
            ndc_x *= double(getNumColumns()-1);
            ndc_y *= double(getNumRows()-1);
            i = (unsigned int)(ndc_x);
            j = (unsigned int)(ndc_y);
            ir = ndc_x - double(i);
            jr = ndc_y - double(j);
        } 


        inline bool getInterpolatedValue(double ndc_x, double ndc_y, float& value)
        {
            unsigned int i,j;
            double ir, jr;
            computeIndices(ndc_x, ndc_y, i, j, ir, jr);
            value = 0.0f;
            double div = 0.0f;
            float v,r;
            
            r = (1.0f-ir)*(1.0f-jr);
            if (r>0.0 && getValue(i,j,v)) 
            {
                value += v*r;
                div += r;
            }
            
            r = (ir)*(1.0f-jr);
            if (r>0.0 && getValue(i+1,j,v)) 
            {
                value += v*r;
                div += r;
            }
            
            r = (ir)*(jr);
            if (r>0.0 && getValue(i+1,j+1,v)) 
            {
                value += v*r;
                div += r;
            }
            
            r = (1.0f-ir)*(jr);
            if (r>0.0 && getValue(i,j+1,v)) 
            {
                value += v*r;
                div += r;
            }
            
            if (div != 0.0)
            {
                value /= div;
                return true;
            }
            
            value = 0.0;
            return false;
        }

        /** increment the modified count."*/
        virtual void dirty() {};

        /** Set the modified count value.  */
        virtual void setModifiedCount(unsigned int /*value*/) {};

        /** Get modified count value. */
        virtual unsigned int getModifiedCount() const { return 0; }

        virtual osg::BoundingSphere computeBound(bool treatAsElevationLayer) const;

    protected:

        virtual ~Layer();

        std::string                     _filename;
        osg::ref_ptr<Locator>           _locator;
        unsigned int                    _minLevel;
        unsigned int                    _maxLevel;
        osg::ref_ptr<ValidDataOperator> _validDataOperator;
        osg::Vec4                       _defaultValue;
        Filter                          _filter;

};

class OSGTERRAIN_EXPORT ImageLayer : public Layer
{
    public:

        ImageLayer(osg::Image* image=0);

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        ImageLayer(const ImageLayer& imageLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, ImageLayer);

        void setFileName(const std::string& filename) { _filename = filename; if (_image.valid()) _image->setFileName(filename); }
        virtual const std::string& getFileName() const { return _image.get() ? _image->getFileName() : _filename; }

        virtual bool transform(float offset, float scale);

        void setImage(osg::Image* image);

        /** Return image associated with layer. */  
        virtual osg::Image* getImage() { return _image.get(); }

        /** Return const image associated with layer. */
        virtual const osg::Image* getImage() const { return _image.get(); }

        virtual unsigned int getNumColumns() const { return _image.valid() ? _image->s() : 0; }
        virtual unsigned int getNumRows() const { return _image.valid() ? _image->t() : 0;  }

        virtual bool getValue(unsigned int i, unsigned int j, float& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec2& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec3& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec4& value) const;

        virtual void dirty();
        virtual void setModifiedCount(unsigned int value);
        virtual unsigned int getModifiedCount() const;

    protected:

        virtual ~ImageLayer() {}

        osg::ref_ptr<osg::Image>    _image;

};

class OSGTERRAIN_EXPORT ContourLayer : public Layer
{
    public:

        ContourLayer(osg::TransferFunction1D* tf=0);

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        ContourLayer(const ContourLayer& tfLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, ContourLayer);

        virtual bool transform(float offset, float scale);

        void setTransferFunction(osg::TransferFunction1D* tf);
        osg::TransferFunction1D* getTransferFunction() { return _tf.get(); }
        const osg::TransferFunction1D* getTransferFunction() const { return _tf.get(); }

        /** Return image associated with layer. */  
        virtual osg::Image* getImage() { return _tf.valid() ? _tf->getImage() : 0; }

        /** Return const image associated with layer. */
        virtual const osg::Image* getImage() const { return _tf.valid() ? _tf->getImage() : 0; }


        virtual unsigned int getNumColumns() const { return _tf.valid() ? _tf->getNumberCellsX() : 0; }
        virtual unsigned int getNumRows() const { return _tf.valid() ? 1 : 0;  }

        virtual bool getValue(unsigned int i, unsigned int j, float& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec2& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec3& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec4& value) const;

        virtual void dirty();
        virtual void setModifiedCount(unsigned int value);
        virtual unsigned int getModifiedCount() const;

    protected:

        virtual ~ContourLayer() {}

        osg::ref_ptr<osg::TransferFunction1D>    _tf;

};

class OSGTERRAIN_EXPORT HeightFieldLayer : public Layer
{
    public:

        HeightFieldLayer(osg::HeightField* hf=0);

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        HeightFieldLayer(const HeightFieldLayer& hfLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, HeightFieldLayer);

        void setFileName(const std::string& filename) { _filename = filename; }
        virtual const std::string& getFileName() const { return _filename; }

        virtual bool transform(float offset, float scale);

        void setHeightField(osg::HeightField* hf);
        osg::HeightField* getHeightField() { return _heightField.get(); }
        const osg::HeightField* getHeightField() const { return _heightField.get(); }

        virtual unsigned int getNumColumns() const { return _heightField.valid() ? _heightField->getNumColumns() : 0; }
        virtual unsigned int getNumRows() const { return _heightField.valid() ? _heightField->getNumRows() : 0;  }

        virtual bool getValue(unsigned int i, unsigned int j, float& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec2& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec3& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec4& value) const;

        virtual void dirty();
        virtual void setModifiedCount(unsigned int value);
        virtual unsigned int getModifiedCount() const;

    protected:

        virtual ~HeightFieldLayer() {}

        unsigned int                    _modifiedCount;
        osg::ref_ptr<osg::HeightField>  _heightField;

};


class OSGTERRAIN_EXPORT CompositeLayer : public Layer
{
    public:

        CompositeLayer();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        CompositeLayer(const CompositeLayer& compositeLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, CompositeLayer);

        void clear();

        void setFileName(unsigned int i, const std::string& filename) { _layers[i].first = filename; if (_layers[i].second.valid()) _layers[i].second->setFileName(filename); }
        const std::string& getFileName(unsigned int i) const { return _layers[i].second.valid() ? _layers[i].second->getFileName() : _layers[i].first; }

        void setLayer(unsigned int i, Layer* layer) { _layers[i].second = layer; }
        Layer* getLayer(unsigned int i) { return _layers[i].second.get(); }
        const Layer* getLayer(unsigned int i) const { return _layers[i].second.get(); }

        void addLayer(const std::string& filename) { _layers.push_back(FileNameLayerPair(filename,0)); }
        
        void addLayer(Layer* layer) { _layers.push_back(FileNameLayerPair(layer->getFileName(),layer)); }

        void removeLayer(unsigned int i) { _layers.erase(_layers.begin()+i); }
        
        unsigned int getNumLayers() const { return _layers.size(); }

    protected:

        virtual ~CompositeLayer() {}
        
        typedef std::pair< std::string, osg::ref_ptr<Layer> > FileNameLayerPair;
        
        typedef std::vector< FileNameLayerPair > Layers;
        
        Layers _layers;
};

class OSGTERRAIN_EXPORT ProxyLayer : public Layer
{
    public:

        ProxyLayer();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        ProxyLayer(const ProxyLayer& proxyLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, ProxyLayer);
        
        /** Set the implementation layer that does the actual work.*/
        void setImplementation(Layer* layer) { _implementation = layer; }
        
        /** Get the implementation layer that does the actual work.*/
        Layer* getImplementation() { return _implementation.get(); }

        /** Get the const implementation layer that does the actual work.*/
        const Layer* getImplementation() const { return _implementation.get(); }

        virtual void setFileName(const std::string& filename);
        virtual const std::string& getFileName() const { return _filename; }

        virtual unsigned int getNumColumns() const;
        virtual unsigned int getNumRows() const;
        
        virtual bool transform(float offset, float scale);

        virtual bool getValue(unsigned int i, unsigned int j, float& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec2& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec3& value) const;
        virtual bool getValue(unsigned int i, unsigned int j, osg::Vec4& value) const;

        virtual void dirty();
        virtual void setModifiedCount(unsigned int value);
        virtual unsigned int getModifiedCount() const;

        virtual osg::BoundingSphere computeBound(bool treatAsElevationLayer) const;

    protected:

        virtual ~ProxyLayer();
        
        osg::ref_ptr<Layer> _implementation;


};



class OSGTERRAIN_EXPORT SwitchLayer : public Layer
{
    public:

        SwitchLayer();

        /** Copy constructor using CopyOp to manage deep vs shallow copy.*/
        SwitchLayer(const SwitchLayer& switchLayer,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        META_Object(osgTerrain, SwitchLayer);

        void clear();
        
        void setActiveLayer(unsigned int i) { _activeLayer = i; }
        unsigned int getActiveLayer() const { return _activeLayer; }

        void setFileName(unsigned int i, const std::string& filename) { _layers[i].first = filename; if (_layers[i].second.valid()) _layers[i].second->setFileName(filename); }
        const std::string& getFileName(unsigned int i) const { return _layers[i].second.valid() ? _layers[i].second->getFileName() : _layers[i].first; }

        void setLayer(unsigned int i, Layer* layer) { _layers[i].second = layer; }
        Layer* getLayer(unsigned int i) { return _layers[i].second.get(); }
        const Layer* getLayer(unsigned int i) const { return _layers[i].second.get(); }

        void addLayer(const std::string& filename) { _layers.push_back(FileNameLayerPair(filename,0)); }
        
        void addLayer(Layer* layer) { _layers.push_back(FileNameLayerPair(layer->getFileName(),layer)); }

        void removeLayer(unsigned int i) { _layers.erase(_layers.begin()+i); }
        
        unsigned int getNumLayers() const { return _layers.size(); }

    protected:

        virtual ~SwitchLayer() {}
        
        typedef std::pair< std::string, osg::ref_ptr<Layer> > FileNameLayerPair;
        
        typedef std::vector< FileNameLayerPair > Layers;
        
        unsigned int _activeLayer;
        Layers _layers;
};

}

#endif
