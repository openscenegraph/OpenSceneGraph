char volume_cut_tf_frag[] = "uniform sampler3D baseTexture;\n"
						"\n"
						"uniform sampler1D tfTexture;\n"
						"uniform float tfScale;\n"
						"uniform float tfOffset;\n"
						"\n"
						"uniform float SampleDensityValue;\n"
						"uniform float TransparencyValue;\n"
						"uniform float AlphaFuncValue;\n"
						"uniform float CutXFront;\n"
						"uniform float CutXBack;\n"
						"uniform float CutYFront;\n"
						"uniform float CutYBack;\n"
						"uniform float CutZFront;\n"
						"uniform float CutZBack;\n"
						"uniform bool CutBox;\n"
						"\n"
						"varying vec4 cameraPos;\n"
						"varying vec4 vertexPos;\n"
						"varying mat4 texgen;\n"
						"varying vec4 baseColor;\n"
						"\n"
						"void main(void)\n"
						"{ \n"
						"    vec4 t0 = vertexPos;\n"
						"    vec4 te = cameraPos;\n"
						"\n"
						"    if (te.x>=CutXFront && te.x<=CutXBack &&\n"
						"        te.y>=CutYFront && te.y<=CutYBack &&\n"
						"        te.z>=CutZFront && te.z<=CutZBack)\n"
						"    {\n"
						"        // do nothing... te inside volume\n"
						"    }\n"
						"    else\n"
						"    {\n"
						"        if (te.x<CutXFront)\n"
						"        {\n"
						"            float r = (CutXFront-te.x) / (t0.x-te.x);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"\n"
						"        if (te.x>CutXBack)\n"
						"        {\n"
						"            float r = (CutXBack-te.x) / (t0.x-te.x);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"\n"
						"        if (te.y<CutYFront)\n"
						"        {\n"
						"            float r = (CutYFront-te.y) / (t0.y-te.y);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"\n"
						"        if (te.y>CutYBack)\n"
						"        {\n"
						"            float r = (CutYBack-te.y) / (t0.y-te.y);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"\n"
						"        if (te.z<CutZFront)\n"
						"        {\n"
						"            float r = (CutZFront-te.z) / (t0.z-te.z);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"\n"
						"        if (te.z>CutZBack)\n"
						"        {\n"
						"            float r = (CutZBack-te.z) / (t0.z-te.z);\n"
						"            te = te + (t0-te)*r;\n"
						"        }\n"
						"    }\n"
						"\n"
						"    t0 = t0 * texgen;\n"
						"    te = te * texgen;\n"
						"\n"
						"    const float max_iteratrions = 2048.0;\n"
						"    float num_iterations = ceil(length((te-t0).xyz)/SampleDensityValue);\n"
						"    if (num_iterations<2.0) num_iterations = 2.0;\n"
						"\n"
						"    if (num_iterations>max_iteratrions) \n"
						"    {\n"
						"        num_iterations = max_iteratrions;\n"
						"    }\n"
						"\n"
						"    vec3 deltaTexCoord=(te-t0).xyz/float(num_iterations-1.0);\n"
						"    vec3 texcoord = t0.xyz;\n"
						"\n"
						"    vec4 fragColor = vec4(0.0, 0.0, 0.0, 0.0); \n"
						"    while(num_iterations>0.0)\n"
						"    {\n"
						"        float v = texture3D( baseTexture, texcoord).r;\n"
						"		 if (v < 0.1) v=v+0.001;\n"
						"        vec4 color = texture1D( tfTexture, v);\n"
						"\n"
						"        float r = color[3]*TransparencyValue;\n"
						"        if (r>AlphaFuncValue)\n"
						"        {\n"
						"            fragColor.xyz = fragColor.xyz*(1.0-r)+color.xyz*r;\n"
						"            fragColor.w += r;\n"
						"        }\n"
						"\n"
						"        texcoord += deltaTexCoord; \n"
						"\n"
						"        --num_iterations;\n"
						"    }\n"
						"\n"
						"    fragColor.w *= TransparencyValue;\n"
						"    if (fragColor.w>1.0) fragColor.w = 1.0;\n"
						"\n"
						"    fragColor *= baseColor;\n"
						"\n"
						"    if (fragColor.w<AlphaFuncValue) discard;\n"
						"    \n"
						"    gl_FragColor = fragColor;\n"
						"}\n"
						"\n";
