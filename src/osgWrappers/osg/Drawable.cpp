// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/BoundingBox>
#include <osg/CopyOp>
#include <osg/Drawable>
#include <osg/Geometry>
#include <osg/Node>
#include <osg/NodeVisitor>
#include <osg/Object>
#include <osg/PrimitiveSet>
#include <osg/RenderInfo>
#include <osg/Shape>
#include <osg/State>
#include <osg/StateSet>
#include <osg/Vec2>
#include <osg/Vec2d>
#include <osg/Vec3>
#include <osg/Vec3d>
#include <osg/Vec4>
#include <osg/Vec4d>
#include <osg/Vec4ub>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

TYPE_NAME_ALIAS(std::vector< osg::Node * >, osg::Drawable::ParentList)

TYPE_NAME_ALIAS(unsigned int, osg::Drawable::AttributeType)

BEGIN_ENUM_REFLECTOR(osg::Drawable::AttributeTypes)
	I_DeclaringFile("osg/Drawable");
	I_EnumLabel(osg::Drawable::VERTICES);
	I_EnumLabel(osg::Drawable::WEIGHTS);
	I_EnumLabel(osg::Drawable::NORMALS);
	I_EnumLabel(osg::Drawable::COLORS);
	I_EnumLabel(osg::Drawable::SECONDARY_COLORS);
	I_EnumLabel(osg::Drawable::FOG_COORDS);
	I_EnumLabel(osg::Drawable::ATTRIBUTE_6);
	I_EnumLabel(osg::Drawable::ATTRIBUTE_7);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_0);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_1);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_2);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_3);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_4);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_5);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_6);
	I_EnumLabel(osg::Drawable::TEXTURE_COORDS_7);
END_REFLECTOR

BEGIN_ABSTRACT_OBJECT_REFLECTOR(osg::Drawable)
	I_DeclaringFile("osg/Drawable");
	I_BaseType(osg::Object);
	I_Constructor0(____Drawable,
	               "",
	               "");
	I_ConstructorWithDefaults2(IN, const osg::Drawable &, drawable, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY,
	                           ____Drawable__C5_Drawable_R1__C5_CopyOp_R1,
	                           "Copy constructor using CopyOp to manage deep vs shallow copy. ",
	                           "");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method0(osg::Geometry *, asGeometry,
	          Properties::VIRTUAL,
	          __Geometry_P1__asGeometry,
	          "Convert 'this' into a Geometry pointer if Drawable is a Geometry, otherwise return 0. ",
	          "Equivalent to dynamic_cast<Geometry*>(this). ");
	I_Method0(const osg::Geometry *, asGeometry,
	          Properties::VIRTUAL,
	          __C5_Geometry_P1__asGeometry,
	          "Convert 'const this' into a const Geometry pointer if Drawable is a Geometry, otherwise return 0. ",
	          "Equivalent to dynamic_cast<const Geometry*>(this). ");
	I_Method0(void, computeDataVariance,
	          Properties::VIRTUAL,
	          __void__computeDataVariance,
	          "Compute the DataVariance based on an assessment of callback etc. ",
	          "");
	I_Method0(const osg::Drawable::ParentList &, getParents,
	          Properties::NON_VIRTUAL,
	          __C5_ParentList_R1__getParents,
	          "Get the parent list of drawable. ",
	          "");
	I_Method0(osg::Drawable::ParentList, getParents,
	          Properties::NON_VIRTUAL,
	          __ParentList__getParents,
	          "Get the a copy of parent list of node. ",
	          "A copy is returned to prevent modification of the parent list. ");
	I_Method1(osg::Node *, getParent, IN, unsigned int, i,
	          Properties::NON_VIRTUAL,
	          __Node_P1__getParent__unsigned_int,
	          "Get a single parent of Drawable. ",
	          " param i index of the parent to get.   return the parent i. ");
	I_Method1(const osg::Node *, getParent, IN, unsigned int, i,
	          Properties::NON_VIRTUAL,
	          __C5_Node_P1__getParent__unsigned_int,
	          "Get a single const parent of Drawable. ",
	          " param i index of the parent to get.   return the parent i. ");
	I_Method0(unsigned int, getNumParents,
	          Properties::NON_VIRTUAL,
	          __unsigned_int__getNumParents,
	          "Get the number of parents of node. ",
	          "the number of parents of this node.  ");
	I_MethodWithDefaults1(osg::MatrixList, getWorldMatrices, IN, const osg::Node *, haltTraversalAtNode, 0,
	                      Properties::NON_VIRTUAL,
	                      __MatrixList__getWorldMatrices__C5_osg_Node_P1,
	                      "Get the list of matrices that transform this node from local coordinates to world coordinates. ",
	                      "The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node. ");
	I_Method1(void, setStateSet, IN, osg::StateSet *, stateset,
	          Properties::NON_VIRTUAL,
	          __void__setStateSet__StateSet_P1,
	          "Set the StateSet attached to the Drawable. ",
	          "Previously attached StateSet are automatically unreferenced on assignment of a new drawstate. ");
	I_Method0(osg::StateSet *, getStateSet,
	          Properties::NON_VIRTUAL,
	          __StateSet_P1__getStateSet,
	          "Get the attached StateSet. ",
	          "");
	I_Method0(const osg::StateSet *, getStateSet,
	          Properties::NON_VIRTUAL,
	          __C5_StateSet_P1__getStateSet,
	          "Get the attached const StateSet. ",
	          "");
	I_Method0(osg::StateSet *, getOrCreateStateSet,
	          Properties::NON_VIRTUAL,
	          __StateSet_P1__getOrCreateStateSet,
	          "Get the attached const StateSet, if one is not already attached create one, attach it to the drawable and return a pointer to it. ",
	          "");
	I_Method1(void, setInitialBound, IN, const osg::BoundingBox &, bbox,
	          Properties::NON_VIRTUAL,
	          __void__setInitialBound__C5_osg_BoundingBox_R1,
	          "Set the initial bounding volume to use when computing the overall bounding volume. ",
	          "");
	I_Method0(const osg::BoundingBox &, getInitialBound,
	          Properties::NON_VIRTUAL,
	          __C5_BoundingBox_R1__getInitialBound,
	          "Set the initial bounding volume to use when computing the overall bounding volume. ",
	          "");
	I_Method0(void, dirtyBound,
	          Properties::NON_VIRTUAL,
	          __void__dirtyBound,
	          "Dirty the bounding box, forcing a computeBound() on the next call to getBound(). ",
	          "Should be called in the internal geometry of the Drawable is modified. ");
	I_Method0(const osg::BoundingBox &, getBound,
	          Properties::NON_VIRTUAL,
	          __C5_BoundingBox_R1__getBound,
	          "Get BoundingBox of Drawable. ",
	          "If the BoundingBox is not up to date then its updated via an internal call to computeBond(). ");
	I_Method0(osg::BoundingBox, computeBound,
	          Properties::VIRTUAL,
	          __BoundingBox__computeBound,
	          "Compute the bounding box around Drawables's geometry. ",
	          "");
	I_Method1(void, setComputeBoundingBoxCallback, IN, osg::Drawable::ComputeBoundingBoxCallback *, callback,
	          Properties::NON_VIRTUAL,
	          __void__setComputeBoundingBoxCallback__ComputeBoundingBoxCallback_P1,
	          "Set the compute bound callback to override the default computeBound. ",
	          "");
	I_Method0(osg::Drawable::ComputeBoundingBoxCallback *, getComputeBoundingBoxCallback,
	          Properties::NON_VIRTUAL,
	          __ComputeBoundingBoxCallback_P1__getComputeBoundingBoxCallback,
	          "Get the compute bound callback. ",
	          "");
	I_Method0(const osg::Drawable::ComputeBoundingBoxCallback *, getComputeBoundingBoxCallback,
	          Properties::NON_VIRTUAL,
	          __C5_ComputeBoundingBoxCallback_P1__getComputeBoundingBoxCallback,
	          "Get the const compute bound callback. ",
	          "");
	I_Method1(void, setShape, IN, osg::Shape *, shape,
	          Properties::NON_VIRTUAL,
	          __void__setShape__Shape_P1,
	          "Set the Shape of the Drawable. ",
	          "The shape can be used to speed up collision detection or as a guide for procedural geometry generation. osg::Shape.  ");
	I_Method0(osg::Shape *, getShape,
	          Properties::NON_VIRTUAL,
	          __Shape_P1__getShape,
	          "Get the Shape of the Drawable. ",
	          "");
	I_Method0(const osg::Shape *, getShape,
	          Properties::NON_VIRTUAL,
	          __C5_Shape_P1__getShape,
	          "Get the const Shape of the const Drawable. ",
	          "");
	I_Method1(void, setSupportsDisplayList, IN, bool, flag,
	          Properties::NON_VIRTUAL,
	          __void__setSupportsDisplayList__bool,
	          "Set the drawable so that it can or cannot be used in conjunction with OpenGL display lists. ",
	          "When set to true, calls to Drawable::setUseDisplayList, whereas when set to false, no display lists can be created and calls to setUseDisplayList are ignored, and a warning is produced. The latter is typically used to guard against the switching on of display lists on objects with dynamic internal data such as continuous Level of Detail algorithms. ");
	I_Method0(bool, getSupportsDisplayList,
	          Properties::NON_VIRTUAL,
	          __bool__getSupportsDisplayList,
	          "Get whether display lists are supported for this drawable instance. ",
	          "");
	I_Method1(void, setUseDisplayList, IN, bool, flag,
	          Properties::NON_VIRTUAL,
	          __void__setUseDisplayList__bool,
	          "When set to true, force the draw method to use OpenGL Display List for rendering. ",
	          "If false, rendering directly. If the display list has not been compiled already, the next call to draw will automatically create the display list. ");
	I_Method0(bool, getUseDisplayList,
	          Properties::NON_VIRTUAL,
	          __bool__getUseDisplayList,
	          "Return whether OpenGL display lists are being used for rendering. ",
	          "");
	I_Method1(GLuint &, getDisplayList, IN, unsigned int, contextID,
	          Properties::NON_VIRTUAL,
	          __GLuint_R1__getDisplayList__unsigned_int,
	          "Return OpenGL display list for specified contextID. ",
	          "");
	I_Method1(void, setUseVertexBufferObjects, IN, bool, flag,
	          Properties::VIRTUAL,
	          __void__setUseVertexBufferObjects__bool,
	          "When set to true, ignore the setUseDisplayList() settings, and hints to the drawImplementation method to use OpenGL vertex buffer objects for rendering. ",
	          "");
	I_Method0(bool, getUseVertexBufferObjects,
	          Properties::NON_VIRTUAL,
	          __bool__getUseVertexBufferObjects,
	          "Return whether OpenGL vertex buffer objects should be used when supported by OpenGL driver. ",
	          "");
	I_Method0(void, dirtyDisplayList,
	          Properties::VIRTUAL,
	          __void__dirtyDisplayList,
	          "Force a recompile on next draw() of any OpenGL display list associated with this geoset. ",
	          "");
	I_Method0(unsigned int, getGLObjectSizeHint,
	          Properties::VIRTUAL,
	          __unsigned_int__getGLObjectSizeHint,
	          "Return the estimated size of GLObjects (display lists/vertex buffer objects) that are associated with this drawable. ",
	          "This size is used a hint for reuse of deleted display lists/vertex buffer objects. ");
	I_Method1(void, draw, IN, osg::RenderInfo &, renderInfo,
	          Properties::NON_VIRTUAL,
	          __void__draw__RenderInfo_R1,
	          "Draw OpenGL primitives. ",
	          "If the Drawable has _useDisplayList set to true, then use an OpenGL display list, automatically compiling one if required. Otherwise, call drawImplementation(). This method should not be overridden in subclasses, as it manages the optional display list (notice this is not even virtual). Subclasses should override drawImplementation() instead.  ");
	I_Method1(void, compileGLObjects, IN, osg::RenderInfo &, renderInfo,
	          Properties::VIRTUAL,
	          __void__compileGLObjects__RenderInfo_R1,
	          "Immediately compile this Drawable into an OpenGL Display List. ",
	          "Operation is ignored if _useDisplayList is false.  ");
	I_Method1(void, setThreadSafeRefUnref, IN, bool, threadSafe,
	          Properties::VIRTUAL,
	          __void__setThreadSafeRefUnref__bool,
	          "Set whether to use a mutex to ensure ref() and unref() are thread safe. ",
	          "");
	I_Method1(void, resizeGLObjectBuffers, IN, unsigned int, maxSize,
	          Properties::VIRTUAL,
	          __void__resizeGLObjectBuffers__unsigned_int,
	          "Resize any per context GLObject buffers to specified size. ",
	          "");
	I_MethodWithDefaults1(void, releaseGLObjects, IN, osg::State *, state, 0,
	                      Properties::VIRTUAL,
	                      __void__releaseGLObjects__State_P1,
	                      "If State is non-zero, this function releases OpenGL objects for the specified graphics context. ",
	                      "Otherwise, releases OpenGL objects for all graphics contexts. ");
	I_Method1(void, setUpdateCallback, IN, osg::Drawable::UpdateCallback *, ac,
	          Properties::VIRTUAL,
	          __void__setUpdateCallback__UpdateCallback_P1,
	          "Set the UpdateCallback which allows users to attach customize the updating of an object during the update traversal. ",
	          "");
	I_Method0(osg::Drawable::UpdateCallback *, getUpdateCallback,
	          Properties::NON_VIRTUAL,
	          __UpdateCallback_P1__getUpdateCallback,
	          "Get the non const UpdateCallback. ",
	          "");
	I_Method0(const osg::Drawable::UpdateCallback *, getUpdateCallback,
	          Properties::NON_VIRTUAL,
	          __C5_UpdateCallback_P1__getUpdateCallback,
	          "Get the const UpdateCallback. ",
	          "");
	I_Method0(bool, requiresUpdateTraversal,
	          Properties::NON_VIRTUAL,
	          __bool__requiresUpdateTraversal,
	          "Return whether this Drawable has update callbacks associated with it, and therefore must be traversed. ",
	          "");
	I_Method1(void, setEventCallback, IN, osg::Drawable::EventCallback *, ac,
	          Properties::VIRTUAL,
	          __void__setEventCallback__EventCallback_P1,
	          "Set the EventCallback which allows users to attach customize the updating of an object during the Event traversal. ",
	          "");
	I_Method0(osg::Drawable::EventCallback *, getEventCallback,
	          Properties::NON_VIRTUAL,
	          __EventCallback_P1__getEventCallback,
	          "Get the non const EventCallback. ",
	          "");
	I_Method0(const osg::Drawable::EventCallback *, getEventCallback,
	          Properties::NON_VIRTUAL,
	          __C5_EventCallback_P1__getEventCallback,
	          "Get the const EventCallback. ",
	          "");
	I_Method0(bool, requiresEventTraversal,
	          Properties::NON_VIRTUAL,
	          __bool__requiresEventTraversal,
	          "Return whether this Drawable has event callbacks associated with it, and therefore must be traversed. ",
	          "");
	I_Method1(void, setCullCallback, IN, osg::Drawable::CullCallback *, cc,
	          Properties::VIRTUAL,
	          __void__setCullCallback__CullCallback_P1,
	          "Set the CullCallback which allows users to customize the culling of Drawable during the cull traversal. ",
	          "");
	I_Method0(osg::Drawable::CullCallback *, getCullCallback,
	          Properties::NON_VIRTUAL,
	          __CullCallback_P1__getCullCallback,
	          "Get the non const CullCallback. ",
	          "");
	I_Method0(const osg::Drawable::CullCallback *, getCullCallback,
	          Properties::NON_VIRTUAL,
	          __C5_CullCallback_P1__getCullCallback,
	          "Get the const CullCallback. ",
	          "");
	I_Method1(void, setDrawCallback, IN, osg::Drawable::DrawCallback *, dc,
	          Properties::VIRTUAL,
	          __void__setDrawCallback__DrawCallback_P1,
	          "Set the DrawCallback which allows users to attach customize the drawing of existing Drawable object. ",
	          "");
	I_Method0(osg::Drawable::DrawCallback *, getDrawCallback,
	          Properties::NON_VIRTUAL,
	          __DrawCallback_P1__getDrawCallback,
	          "Get the non const DrawCallback. ",
	          "");
	I_Method0(const osg::Drawable::DrawCallback *, getDrawCallback,
	          Properties::NON_VIRTUAL,
	          __C5_DrawCallback_P1__getDrawCallback,
	          "Get the const DrawCallback. ",
	          "");
	I_Method1(void, drawImplementation, IN, osg::RenderInfo &, renderInfo,
	          Properties::PURE_VIRTUAL,
	          __void__drawImplementation__RenderInfo_R1,
	          "drawImplementation(RenderInfo&) is a pure virtual method for the actual implementation of OpenGL drawing calls, such as vertex arrays and primitives, that must be implemented in concrete subclasses of the Drawable base class, examples include osg::Geometry and osg::ShapeDrawable. ",
	          " param renderInfo The osg::RenderInfo object that encapsulates the current rendering information including the osg::State OpenGL state for the current graphics context.  ");
	I_Method1(bool, supports, IN, const osg::Drawable::AttributeFunctor &, x,
	          Properties::VIRTUAL,
	          __bool__supports__C5_AttributeFunctor_R1,
	          "Return true if the Drawable subclass supports accept(AttributeFunctor&). ",
	          "");
	I_Method1(void, accept, IN, osg::Drawable::AttributeFunctor &, x,
	          Properties::VIRTUAL,
	          __void__accept__AttributeFunctor_R1,
	          "accept an AttributeFunctor and call its methods to tell it about the internal attributes that this Drawable has. ",
	          "return true if functor handled by drawable, return false on failure of drawable to generate functor calls. ");
	I_Method1(bool, supports, IN, const osg::Drawable::ConstAttributeFunctor &, x,
	          Properties::VIRTUAL,
	          __bool__supports__C5_ConstAttributeFunctor_R1,
	          "Return true if the Drawable subclass supports accept(ConstAttributeFunctor&). ",
	          "");
	I_Method1(void, accept, IN, osg::Drawable::ConstAttributeFunctor &, x,
	          Properties::VIRTUAL,
	          __void__accept__ConstAttributeFunctor_R1,
	          "Accept an AttributeFunctor and call its methods to tell it about the internal attributes that this Drawable has. ",
	          "return true if functor handled by drawable, return false on failure of drawable to generate functor calls. ");
	I_Method1(bool, supports, IN, const osg::PrimitiveFunctor &, x,
	          Properties::VIRTUAL,
	          __bool__supports__C5_PrimitiveFunctor_R1,
	          "Return true if the Drawable subclass supports accept(PrimitiveFunctor&). ",
	          "");
	I_Method1(void, accept, IN, osg::PrimitiveFunctor &, x,
	          Properties::VIRTUAL,
	          __void__accept__PrimitiveFunctor_R1,
	          "Accept a PrimitiveFunctor and call its methods to tell it about the internal primitives that this Drawable has. ",
	          "return true if functor handled by drawable, return false on failure of drawable to generate functor calls. Note, PrimtiveFunctor only provides const access of the primitives, as primitives may be procedurally generated so one cannot modify it. ");
	I_Method1(bool, supports, IN, const osg::PrimitiveIndexFunctor &, x,
	          Properties::VIRTUAL,
	          __bool__supports__C5_PrimitiveIndexFunctor_R1,
	          "Return true if the Drawable subclass supports accept(PrimitiveIndexFunctor&). ",
	          "");
	I_Method1(void, accept, IN, osg::PrimitiveIndexFunctor &, x,
	          Properties::VIRTUAL,
	          __void__accept__PrimitiveIndexFunctor_R1,
	          "Accept a PrimitiveIndexFunctor and call its methods to tell it about the internal primitives that this Drawable has. ",
	          "return true if functor handled by drawable, return false on failure of drawable to generate functor calls. Note, PrimtiveIndexFunctor only provide const access of the primitives, as primitives may be procedurally generated so one cannot modify it. ");
	I_StaticMethodWithDefaults2(GLuint, generateDisplayList, IN, unsigned int, contextID, , IN, unsigned int, sizeHint, 0,
	                            __GLuint__generateDisplayList__unsigned_int__unsigned_int_S,
	                            "Return a OpenGL display list handle a newly generated or reused from display list cache. ",
	                            "");
	I_StaticMethod1(void, setMinimumNumberOfDisplayListsToRetainInCache, IN, unsigned int, minimum,
	                __void__setMinimumNumberOfDisplayListsToRetainInCache__unsigned_int_S,
	                "Set the minimum number of display lists to retain in the deleted display list cache. ",
	                "");
	I_StaticMethod0(unsigned int, getMinimumNumberOfDisplayListsToRetainInCache,
	                __unsigned_int__getMinimumNumberOfDisplayListsToRetainInCache_S,
	                "Get the minimum number of display lists to retain in the deleted display list cache. ",
	                "");
	I_StaticMethodWithDefaults3(void, deleteDisplayList, IN, unsigned int, contextID, , IN, GLuint, globj, , IN, unsigned int, sizeHint, 0,
	                            __void__deleteDisplayList__unsigned_int__GLuint__unsigned_int_S,
	                            "Use deleteDisplayList instead of glDeleteList to allow OpenGL display list to be cached until they can be deleted by the OpenGL context in which they were created, specified by contextID. ",
	                            "");
	I_StaticMethod1(void, flushAllDeletedDisplayLists, IN, unsigned int, contextID,
	                __void__flushAllDeletedDisplayLists__unsigned_int_S,
	                "Flush all the cached display list which need to be deleted in the OpenGL context related to contextID. ",
	                "");
	I_StaticMethod1(void, discardAllDeletedDisplayLists, IN, unsigned int, contextID,
	                __void__discardAllDeletedDisplayLists__unsigned_int_S,
	                "Flush all the cached display list which need to be deleted in the OpenGL context related to contextID. ",
	                "Note, unlike flush no OpenGL calls are made, instead the handles are all removed. this call is useful for when an OpenGL context has been destroyed. ");
	I_StaticMethod2(void, flushDeletedDisplayLists, IN, unsigned int, contextID, IN, double &, availableTime,
	                __void__flushDeletedDisplayLists__unsigned_int__double_R1_S,
	                "Flush the cached display list which need to be deleted in the OpenGL context related to contextID. ",
	                "");
	I_StaticMethod2(osg::Drawable::Extensions *, getExtensions, IN, unsigned int, contextID, IN, bool, createIfNotInitalized,
	                __Extensions_P1__getExtensions__unsigned_int__bool_S,
	                "Function to call to get the extension of a specified context. ",
	                "If the Extension object for that context has not yet been created and the 'createIfNotInitalized' flag been set to false then returns NULL. If 'createIfNotInitalized' is true then the Extensions object is automatically created. However, in this case the extension object is only created with the graphics context associated with ContextID.. ");
	I_StaticMethod2(void, setExtensions, IN, unsigned int, contextID, IN, osg::Drawable::Extensions *, extensions,
	                __void__setExtensions__unsigned_int__Extensions_P1_S,
	                "setExtensions allows users to override the extensions across graphics contexts. ",
	                "typically used when you have different extensions supported across graphics pipes but need to ensure that they all use the same low common denominator extensions. ");
	I_ProtectedMethod1(void, setBound, IN, const osg::BoundingBox &, bb,
	                   Properties::NON_VIRTUAL,
	                   Properties::CONST,
	                   __void__setBound__C5_BoundingBox_R1,
	                   "set the bounding box . ",
	                   "");
	I_ProtectedMethod1(void, addParent, IN, osg::Node *, node,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__addParent__osg_Node_P1,
	                   "",
	                   "");
	I_ProtectedMethod1(void, removeParent, IN, osg::Node *, node,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__removeParent__osg_Node_P1,
	                   "",
	                   "");
	I_ProtectedMethod1(void, setNumChildrenRequiringUpdateTraversal, IN, unsigned int, num,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__setNumChildrenRequiringUpdateTraversal__unsigned_int,
	                   "",
	                   "");
	I_ProtectedMethod0(unsigned int, getNumChildrenRequiringUpdateTraversal,
	                   Properties::NON_VIRTUAL,
	                   Properties::CONST,
	                   __unsigned_int__getNumChildrenRequiringUpdateTraversal,
	                   "",
	                   "");
	I_ProtectedMethod1(void, setNumChildrenRequiringEventTraversal, IN, unsigned int, num,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__setNumChildrenRequiringEventTraversal__unsigned_int,
	                   "",
	                   "");
	I_ProtectedMethod0(unsigned int, getNumChildrenRequiringEventTraversal,
	                   Properties::NON_VIRTUAL,
	                   Properties::CONST,
	                   __unsigned_int__getNumChildrenRequiringEventTraversal,
	                   "",
	                   "");
	I_SimpleProperty(const osg::BoundingBox &, Bound, 
	                 __C5_BoundingBox_R1__getBound, 
	                 0);
	I_SimpleProperty(osg::Drawable::ComputeBoundingBoxCallback *, ComputeBoundingBoxCallback, 
	                 __ComputeBoundingBoxCallback_P1__getComputeBoundingBoxCallback, 
	                 __void__setComputeBoundingBoxCallback__ComputeBoundingBoxCallback_P1);
	I_SimpleProperty(osg::Drawable::CullCallback *, CullCallback, 
	                 __CullCallback_P1__getCullCallback, 
	                 __void__setCullCallback__CullCallback_P1);
	I_SimpleProperty(osg::Drawable::DrawCallback *, DrawCallback, 
	                 __DrawCallback_P1__getDrawCallback, 
	                 __void__setDrawCallback__DrawCallback_P1);
	I_SimpleProperty(osg::Drawable::EventCallback *, EventCallback, 
	                 __EventCallback_P1__getEventCallback, 
	                 __void__setEventCallback__EventCallback_P1);
	I_SimpleProperty(unsigned int, GLObjectSizeHint, 
	                 __unsigned_int__getGLObjectSizeHint, 
	                 0);
	I_SimpleProperty(const osg::BoundingBox &, InitialBound, 
	                 __C5_BoundingBox_R1__getInitialBound, 
	                 __void__setInitialBound__C5_osg_BoundingBox_R1);
	I_ArrayProperty(osg::Node *, Parent, 
	                __Node_P1__getParent__unsigned_int, 
	                0, 
	                __unsigned_int__getNumParents, 
	                0, 
	                0, 
	                0);
	I_SimpleProperty(osg::Drawable::ParentList, Parents, 
	                 __ParentList__getParents, 
	                 0);
	I_SimpleProperty(osg::Shape *, Shape, 
	                 __Shape_P1__getShape, 
	                 __void__setShape__Shape_P1);
	I_SimpleProperty(osg::StateSet *, StateSet, 
	                 __StateSet_P1__getStateSet, 
	                 __void__setStateSet__StateSet_P1);
	I_SimpleProperty(bool, SupportsDisplayList, 
	                 __bool__getSupportsDisplayList, 
	                 __void__setSupportsDisplayList__bool);
	I_SimpleProperty(bool, ThreadSafeRefUnref, 
	                 0, 
	                 __void__setThreadSafeRefUnref__bool);
	I_SimpleProperty(osg::Drawable::UpdateCallback *, UpdateCallback, 
	                 __UpdateCallback_P1__getUpdateCallback, 
	                 __void__setUpdateCallback__UpdateCallback_P1);
	I_SimpleProperty(bool, UseDisplayList, 
	                 __bool__getUseDisplayList, 
	                 __void__setUseDisplayList__bool);
	I_SimpleProperty(bool, UseVertexBufferObjects, 
	                 __bool__getUseVertexBufferObjects, 
	                 __void__setUseVertexBufferObjects__bool);
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::Drawable::AttributeFunctor)
	I_DeclaringFile("osg/Drawable");
	I_Constructor0(____AttributeFunctor,
	               "",
	               "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLbyte *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLbyte_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLshort *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLshort_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLint *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLint_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLubyte *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLubyte_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLushort *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLushort_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, GLuint *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__GLuint_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, float *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__float_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec2 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec2_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec3 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec3_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec4 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec4_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec4ub *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec4ub_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, double *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__double_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec2d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec2d_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec3d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec3d_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, osg::Vec4d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__Vec4d_P1,
	          "",
	          "");
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Drawable::ComputeBoundingBoxCallback)
	I_DeclaringFile("osg/Drawable");
	I_BaseType(osg::Object);
	I_Constructor0(____ComputeBoundingBoxCallback,
	               "",
	               "");
	I_Constructor2(IN, const osg::Drawable::ComputeBoundingBoxCallback &, x, IN, const osg::CopyOp &, x,
	               ____ComputeBoundingBoxCallback__C5_ComputeBoundingBoxCallback_R1__C5_CopyOp_R1,
	               "",
	               "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::BoundingBox, computeBound, IN, const osg::Drawable &, x,
	          Properties::VIRTUAL,
	          __BoundingBox__computeBound__C5_osg_Drawable_R1,
	          "",
	          "");
END_REFLECTOR

BEGIN_VALUE_REFLECTOR(osg::Drawable::ConstAttributeFunctor)
	I_DeclaringFile("osg/Drawable");
	I_Constructor0(____ConstAttributeFunctor,
	               "",
	               "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLbyte *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLbyte_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLshort *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLshort_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLint *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLint_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLubyte *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLubyte_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLushort *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLushort_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const GLuint *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_GLuint_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const float *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_float_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec2 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec2_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec3 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec3_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec4 *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec4_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec4ub *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec4ub_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const double *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_double_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec2d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec2d_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec3d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec3d_P1,
	          "",
	          "");
	I_Method3(void, apply, IN, osg::Drawable::AttributeType, x, IN, unsigned, int, IN, const osg::Vec4d *, x,
	          Properties::VIRTUAL,
	          __void__apply__AttributeType__unsigned__C5_Vec4d_P1,
	          "",
	          "");
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Drawable::CullCallback)
	I_DeclaringFile("osg/Drawable");
	I_VirtualBaseType(osg::Object);
	I_Constructor0(____CullCallback,
	               "",
	               "");
	I_Constructor2(IN, const osg::Drawable::CullCallback &, x, IN, const osg::CopyOp &, x,
	               ____CullCallback__C5_CullCallback_R1__C5_CopyOp_R1,
	               "",
	               "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method3(bool, cull, IN, osg::NodeVisitor *, x, IN, osg::Drawable *, x, IN, osg::State *, x,
	          Properties::VIRTUAL,
	          __bool__cull__osg_NodeVisitor_P1__osg_Drawable_P1__osg_State_P1,
	          "deprecated. ",
	          "");
	I_Method3(bool, cull, IN, osg::NodeVisitor *, nv, IN, osg::Drawable *, drawable, IN, osg::RenderInfo *, renderInfo,
	          Properties::VIRTUAL,
	          __bool__cull__osg_NodeVisitor_P1__osg_Drawable_P1__osg_RenderInfo_P1,
	          "do customized cull code, return true if drawable should be culled. ",
	          "");
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Drawable::DrawCallback)
	I_DeclaringFile("osg/Drawable");
	I_VirtualBaseType(osg::Object);
	I_Constructor0(____DrawCallback,
	               "",
	               "");
	I_Constructor2(IN, const osg::Drawable::DrawCallback &, x, IN, const osg::CopyOp &, x,
	               ____DrawCallback__C5_DrawCallback_R1__C5_CopyOp_R1,
	               "",
	               "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method2(void, drawImplementation, IN, osg::RenderInfo &, x, IN, const osg::Drawable *, x,
	          Properties::VIRTUAL,
	          __void__drawImplementation__osg_RenderInfo_R1__C5_osg_Drawable_P1,
	          "do customized draw code. ",
	          "");
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Drawable::EventCallback)
	I_DeclaringFile("osg/Drawable");
	I_VirtualBaseType(osg::Object);
	I_Constructor0(____EventCallback,
	               "",
	               "");
	I_Constructor2(IN, const osg::Drawable::EventCallback &, x, IN, const osg::CopyOp &, x,
	               ____EventCallback__C5_EventCallback_R1__C5_CopyOp_R1,
	               "",
	               "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method2(void, event, IN, osg::NodeVisitor *, x, IN, osg::Drawable *, x,
	          Properties::VIRTUAL,
	          __void__event__osg_NodeVisitor_P1__osg_Drawable_P1,
	          "do customized Event code. ",
	          "");
END_REFLECTOR

BEGIN_OBJECT_REFLECTOR(osg::Drawable::UpdateCallback)
	I_DeclaringFile("osg/Drawable");
	I_VirtualBaseType(osg::Object);
	I_Constructor0(____UpdateCallback,
	               "",
	               "");
	I_Constructor2(IN, const osg::Drawable::UpdateCallback &, x, IN, const osg::CopyOp &, x,
	               ____UpdateCallback__C5_UpdateCallback_R1__C5_CopyOp_R1,
	               "",
	               "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, copyop,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method2(void, update, IN, osg::NodeVisitor *, x, IN, osg::Drawable *, x,
	          Properties::VIRTUAL,
	          __void__update__osg_NodeVisitor_P1__osg_Drawable_P1,
	          "do customized update code. ",
	          "");
END_REFLECTOR

STD_VECTOR_REFLECTOR(std::vector< osg::Node * >)

