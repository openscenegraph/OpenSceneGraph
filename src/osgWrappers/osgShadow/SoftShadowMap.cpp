// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/CopyOp>
#include <osg/NodeVisitor>
#include <osg/Object>
#include <osg/Vec2>
#include <osg/Vec2s>
#include <osgShadow/SoftShadowMap>
#include <osgUtil/CullVisitor>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

BEGIN_OBJECT_REFLECTOR(osgShadow::SoftShadowMap)
	I_DeclaringFile("osgShadow/SoftShadowMap");
	I_BaseType(osgShadow::ShadowTechnique);
	I_Constructor0(____SoftShadowMap,
	               "",
	               "");
	I_ConstructorWithDefaults2(IN, const osgShadow::SoftShadowMap &, es, , IN, const osg::CopyOp &, copyop, osg::CopyOp::SHALLOW_COPY,
	                           ____SoftShadowMap__C5_SoftShadowMap_R1__C5_osg_CopyOp_R1,
	                           "",
	                           "");
	I_Method0(osg::Object *, cloneType,
	          Properties::VIRTUAL,
	          __osg_Object_P1__cloneType,
	          "Clone the type of an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(osg::Object *, clone, IN, const osg::CopyOp &, x,
	          Properties::VIRTUAL,
	          __osg_Object_P1__clone__C5_osg_CopyOp_R1,
	          "Clone an object, with Object* return type. ",
	          "Must be defined by derived classes. ");
	I_Method1(bool, isSameKindAs, IN, const osg::Object *, obj,
	          Properties::VIRTUAL,
	          __bool__isSameKindAs__C5_osg_Object_P1,
	          "",
	          "");
	I_Method0(const char *, libraryName,
	          Properties::VIRTUAL,
	          __C5_char_P1__libraryName,
	          "return the name of the object's library. ",
	          "Must be defined by derived classes. The OpenSceneGraph convention is that the namespace of a library is the same as the library name. ");
	I_Method0(const char *, className,
	          Properties::VIRTUAL,
	          __C5_char_P1__className,
	          "return the name of the object's class type. ",
	          "Must be defined by derived classes. ");
	I_Method1(void, setTextureUnit, IN, unsigned int, unit,
	          Properties::NON_VIRTUAL,
	          __void__setTextureUnit__unsigned_int,
	          "Set the texture unit that the shadow texture will be applied on. ",
	          "");
	I_Method0(unsigned int, getTextureUnit,
	          Properties::NON_VIRTUAL,
	          __unsigned_int__getTextureUnit,
	          "Get the texture unit that the shadow texture will be applied on. ",
	          "");
	I_Method1(void, setAmbientBias, IN, const osg::Vec2 &, ambientBias,
	          Properties::NON_VIRTUAL,
	          __void__setAmbientBias__C5_osg_Vec2_R1,
	          "Set the values for the ambient bias the shader will use. ",
	          "");
	I_Method2(void, setTextureSize, IN, int, width, IN, int, height,
	          Properties::NON_VIRTUAL,
	          __void__setTextureSize__int__int,
	          "Set the resolution of the rendertarget texture used for shadow generation. ",
	          "");
	I_Method1(void, setTextureSize, IN, const osg::Vec2s &, x,
	          Properties::NON_VIRTUAL,
	          __void__setTextureSize__C5_osg_Vec2s_R1,
	          "Set the resolution of the rendertarget texture used for shadow generation. ",
	          "");
	I_Method0(const osg::Vec2s &, getTextureSize,
	          Properties::NON_VIRTUAL,
	          __C5_osg_Vec2s_R1__getTextureSize,
	          "Get the resolution of the rendertarget texture used for shadow generation. ",
	          "");
	I_Method1(void, setBias, IN, float, bias,
	          Properties::NON_VIRTUAL,
	          __void__setBias__float,
	          "Add a small bias to the z-value when calculating the MVPT matrix, this can reduce shadow acne problem. ",
	          "Suitable values are 0-0.005 Default is 0. ");
	I_Method0(float, getBias,
	          Properties::NON_VIRTUAL,
	          __float__getBias,
	          "Return the bias value set used when calculating the MVPT matrix. ",
	          "");
	I_Method1(void, setSoftnessWidth, IN, const float, softnesswidth,
	          Properties::NON_VIRTUAL,
	          __void__setSoftnessWidth__C5_float,
	          "Set the values for width of the soft penumbra the shader will use. ",
	          "Zero is for hard shadow (no penumbra). 0.01 is already very soft penumbra. Default is 0.005. ");
	I_Method1(void, setJitteringScale, IN, const float, jitteringscale,
	          Properties::NON_VIRTUAL,
	          __void__setJitteringScale__C5_float,
	          "Set the values for jittering scale the shader will use. ",
	          "Zero is no jittering (i.e. see the banding in penumbra) High values (>64) cause 'pixelization' of the penumbra. Usually but not necessarily power of two number. Default is 32. ");
	I_Method0(const osg::Vec2 &, getAmbientBias,
	          Properties::NON_VIRTUAL,
	          __C5_osg_Vec2_R1__getAmbientBias,
	          "Get the values that are used for the ambient bias in the shader. ",
	          "");
	I_Method0(const float, getSoftnessWidth,
	          Properties::NON_VIRTUAL,
	          __C5_float__getSoftnessWidth,
	          "Get the value used for width of the soft penumbra in the shader. ",
	          "");
	I_Method0(const float, getJitteringScale,
	          Properties::NON_VIRTUAL,
	          __C5_float__getJitteringScale,
	          "Get the value used for jittering scale in the shader. ",
	          "");
	I_Method0(void, init,
	          Properties::VIRTUAL,
	          __void__init,
	          "initialize the ShadowedScene and local cached data structures. ",
	          "");
	I_Method1(void, update, IN, osg::NodeVisitor &, nv,
	          Properties::VIRTUAL,
	          __void__update__osg_NodeVisitor_R1,
	          "run the update traversal of the ShadowedScene and update any loca chached data structures. ",
	          "");
	I_Method1(void, cull, IN, osgUtil::CullVisitor &, cv,
	          Properties::VIRTUAL,
	          __void__cull__osgUtil_CullVisitor_R1,
	          "run the cull traversal of the ShadowedScene and set up the rendering for this ShadowTechnique. ",
	          "");
	I_Method0(void, cleanSceneGraph,
	          Properties::VIRTUAL,
	          __void__cleanSceneGraph,
	          "Clean scene graph from any shadow technique specific nodes, state and drawables. ",
	          "");
	I_ProtectedMethod1(void, initJittering, IN, osg::StateSet *, x,
	                   Properties::NON_VIRTUAL,
	                   Properties::NON_CONST,
	                   __void__initJittering__osg_StateSet_P1,
	                   "",
	                   "");
	I_SimpleProperty(const osg::Vec2 &, AmbientBias, 
	                 __C5_osg_Vec2_R1__getAmbientBias, 
	                 __void__setAmbientBias__C5_osg_Vec2_R1);
	I_SimpleProperty(float, Bias, 
	                 __float__getBias, 
	                 __void__setBias__float);
	I_SimpleProperty(const float, JitteringScale, 
	                 __C5_float__getJitteringScale, 
	                 __void__setJitteringScale__C5_float);
	I_SimpleProperty(const float, SoftnessWidth, 
	                 __C5_float__getSoftnessWidth, 
	                 __void__setSoftnessWidth__C5_float);
	I_SimpleProperty(const osg::Vec2s &, TextureSize, 
	                 __C5_osg_Vec2s_R1__getTextureSize, 
	                 __void__setTextureSize__C5_osg_Vec2s_R1);
	I_SimpleProperty(unsigned int, TextureUnit, 
	                 __unsigned_int__getTextureUnit, 
	                 __void__setTextureUnit__unsigned_int);
END_REFLECTOR

